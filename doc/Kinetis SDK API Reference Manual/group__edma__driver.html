<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Kinetis SDK API Reference Manual: eDMA Peripheral Driver</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="fs_logo.gif"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Kinetis SDK API Reference Manual
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">Freescale Semiconductor, Inc.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Introduction</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>API&#160;Usage</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__edma__driver.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">eDMA Peripheral Driver<div class="ingroups"><a class="el" href="group__edma.html">Enhanced Direct Memory Access (eDMA)</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>This section describes the programming interface of the eDMA Peripheral driver.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structedma__user__config__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__edma__driver.html#structedma__user__config__t">edma_user_config_t</a></td></tr>
<tr class="memdesc:structedma__user__config__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">The user configuration structure for the eDMA driver.  <a href="group__edma__driver.html#structedma__user__config__t">More...</a><br/></td></tr>
<tr class="separator:structedma__user__config__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structedma__chn__state__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__edma__driver.html#structedma__chn__state__t">edma_chn_state_t</a></td></tr>
<tr class="memdesc:structedma__chn__state__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure for the eDMA channel.  <a href="group__edma__driver.html#structedma__chn__state__t">More...</a><br/></td></tr>
<tr class="separator:structedma__chn__state__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structedma__scatter__gather__list__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__edma__driver.html#structedma__scatter__gather__list__t">edma_scatter_gather_list_t</a></td></tr>
<tr class="memdesc:structedma__scatter__gather__list__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure for configuring a discrete memory transfer.  <a href="group__edma__driver.html#structedma__scatter__gather__list__t">More...</a><br/></td></tr>
<tr class="separator:structedma__scatter__gather__list__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structedma__state__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__edma__driver.html#structedma__state__t">edma_state_t</a></td></tr>
<tr class="memdesc:structedma__state__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runtime state structure for the eDMA driver.  <a href="group__edma__driver.html#structedma__state__t">More...</a><br/></td></tr>
<tr class="separator:structedma__state__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga7f0960bc8b86ebdf70632f839e914832"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__edma__driver.html#ga7f0960bc8b86ebdf70632f839e914832">STCD_SIZE</a>(number)&#160;&#160;&#160;((number + 1) * 32)</td></tr>
<tr class="memdesc:ga7f0960bc8b86ebdf70632f839e914832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for size of memory need for software TCD.  <a href="#ga7f0960bc8b86ebdf70632f839e914832">More...</a><br/></td></tr>
<tr class="separator:ga7f0960bc8b86ebdf70632f839e914832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9b9b1ae97918288a762d7809de1eab0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae9b9b1ae97918288a762d7809de1eab0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>STCD_ADDR</b>(address)&#160;&#160;&#160;(<a class="el" href="group__edma__hal.html#structedma__software__tcd__t">edma_software_tcd_t</a> *)(((uint32_t)address + 32) &amp; ~0x1FU)</td></tr>
<tr class="separator:gae9b9b1ae97918288a762d7809de1eab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2153971dae04c6beaa8f793ba70b6700"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__edma__driver.html#ga2153971dae04c6beaa8f793ba70b6700">VIRTUAL_CHN_TO_EDMA_MODULE_REGBASE</a>(chn)&#160;&#160;&#160;g_edmaBaseAddr[chn/FSL_FEATURE_EDMA_MODULE_CHANNEL]</td></tr>
<tr class="memdesc:ga2153971dae04c6beaa8f793ba70b6700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to get the eDMA physical module indicator from virtual channel indicator.  <a href="#ga2153971dae04c6beaa8f793ba70b6700">More...</a><br/></td></tr>
<tr class="separator:ga2153971dae04c6beaa8f793ba70b6700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92d18817e1451a961d81c8d4357501d6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__edma__driver.html#ga92d18817e1451a961d81c8d4357501d6">VIRTUAL_CHN_TO_EDMA_CHN</a>(chn)&#160;&#160;&#160;(chn%FSL_FEATURE_EDMA_MODULE_CHANNEL)</td></tr>
<tr class="memdesc:ga92d18817e1451a961d81c8d4357501d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to get the eDMA physical channel indicator from virtual channel indicator.  <a href="#ga92d18817e1451a961d81c8d4357501d6">More...</a><br/></td></tr>
<tr class="separator:ga92d18817e1451a961d81c8d4357501d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5dea015770302df2f22a45a07104ec2e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__edma__driver.html#ga5dea015770302df2f22a45a07104ec2e">VIRTUAL_CHN_TO_DMAMUX_MODULE_REGBASE</a>(chn)&#160;&#160;&#160;g_dmamuxBaseAddr[chn/FSL_FEATURE_DMAMUX_MODULE_CHANNEL]</td></tr>
<tr class="memdesc:ga5dea015770302df2f22a45a07104ec2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to get the DMAMUX physical module indicator from virtual channel indicator.  <a href="#ga5dea015770302df2f22a45a07104ec2e">More...</a><br/></td></tr>
<tr class="separator:ga5dea015770302df2f22a45a07104ec2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46e69802a3047dce07c1075d7049b3a3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__edma__driver.html#ga46e69802a3047dce07c1075d7049b3a3">VIRTUAL_CHN_TO_DMAMUX_CHN</a>(chn)&#160;&#160;&#160;(chn%FSL_FEATURE_DMAMUX_MODULE_CHANNEL)</td></tr>
<tr class="memdesc:ga46e69802a3047dce07c1075d7049b3a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to get the DMAMUX physical channel indicator from virtual channel indicator.  <a href="#ga46e69802a3047dce07c1075d7049b3a3">More...</a><br/></td></tr>
<tr class="separator:ga46e69802a3047dce07c1075d7049b3a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gab79e6ce110f65567abad8afb7dd94309"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__edma__driver.html#gab79e6ce110f65567abad8afb7dd94309">edma_callback_t</a> )(void *parameter, <a class="el" href="group__edma__driver.html#ga10b6a19b129232cb5dbbb2b320c9c224">edma_chn_status_t</a> status)</td></tr>
<tr class="memdesc:gab79e6ce110f65567abad8afb7dd94309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition for the eDMA channel callback function.  <a href="#gab79e6ce110f65567abad8afb7dd94309">More...</a><br/></td></tr>
<tr class="separator:gab79e6ce110f65567abad8afb7dd94309"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga10b6a19b129232cb5dbbb2b320c9c224"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__edma__driver.html#ga10b6a19b129232cb5dbbb2b320c9c224">edma_chn_status_t</a> { <br/>
&#160;&#160;<a class="el" href="group__edma__driver.html#gga10b6a19b129232cb5dbbb2b320c9c224a048d8fdbd086fe00875c1c1eaa5776de">kEDMAChnNormal</a> = 0U, 
<br/>
&#160;&#160;<a class="el" href="group__edma__driver.html#gga10b6a19b129232cb5dbbb2b320c9c224adf8d761a4dfef11c2c96503642e292d7">kEDMAChnIdle</a>, 
<br/>
&#160;&#160;<a class="el" href="group__edma__driver.html#gga10b6a19b129232cb5dbbb2b320c9c224a6e48551773d676e0b0a654f49e8240c5">kEDMAChnError</a>
<br/>
 }</td></tr>
<tr class="memdesc:ga10b6a19b129232cb5dbbb2b320c9c224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Channel status for eDMA channel.  <a href="group__edma__driver.html#ga10b6a19b129232cb5dbbb2b320c9c224">More...</a><br/></td></tr>
<tr class="separator:ga10b6a19b129232cb5dbbb2b320c9c224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2953f24d4e77d2b48a81649b388e0c9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__edma__driver.html#gaf2953f24d4e77d2b48a81649b388e0c9">edma_chn_state_type_t</a> { <br/>
&#160;&#160;<a class="el" href="group__edma__driver.html#ggaf2953f24d4e77d2b48a81649b388e0c9a86bc626247a5202c28081d91d93fff07">kEDMAInvalidChannel</a> = 0xFFU, 
<br/>
&#160;&#160;<a class="el" href="group__edma__driver.html#ggaf2953f24d4e77d2b48a81649b388e0c9a23ba047d4c39c222968ee427f13f0b30">kEDMAAnyChannel</a> = 0xFEU
<br/>
 }</td></tr>
<tr class="memdesc:gaf2953f24d4e77d2b48a81649b388e0c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">enum type for channel allocation.  <a href="group__edma__driver.html#gaf2953f24d4e77d2b48a81649b388e0c9">More...</a><br/></td></tr>
<tr class="separator:gaf2953f24d4e77d2b48a81649b388e0c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7803399034b374663f76a589da7d8419"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__edma__driver.html#ga7803399034b374663f76a589da7d8419">edma_transfer_type_t</a> { <br/>
&#160;&#160;<a class="el" href="group__edma__driver.html#gga7803399034b374663f76a589da7d8419ae94ab12f5f1047bb1d6d7ac7138a0b76">kEDMAPeripheralToMemory</a>, 
<br/>
&#160;&#160;<a class="el" href="group__edma__driver.html#gga7803399034b374663f76a589da7d8419a7439f8629c412b13978697220830e862">kEDMAMemoryToPeripheral</a>, 
<br/>
&#160;&#160;<a class="el" href="group__edma__driver.html#gga7803399034b374663f76a589da7d8419aefd101c1a4783b9efa6595cff7ddea7b">kEDMAMemoryToMemory</a>
<br/>
 }</td></tr>
<tr class="memdesc:ga7803399034b374663f76a589da7d8419"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type for the DMA transfer.  <a href="group__edma__driver.html#ga7803399034b374663f76a589da7d8419">More...</a><br/></td></tr>
<tr class="separator:ga7803399034b374663f76a589da7d8419"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
eDMA peripheral driver module level functions</h2></td></tr>
<tr class="memitem:ga7deb54a7e997d79de1ed7c4e85290688"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__edma__hal.html#gab6319bfbfaebd007f7871ae5be5eebe4">edma_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__edma__driver.html#ga7deb54a7e997d79de1ed7c4e85290688">EDMA_DRV_Init</a> (<a class="el" href="group__edma__driver.html#structedma__state__t">edma_state_t</a> *edmaState, const <a class="el" href="group__edma__driver.html#structedma__user__config__t">edma_user_config_t</a> *userConfig)</td></tr>
<tr class="memdesc:ga7deb54a7e997d79de1ed7c4e85290688"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes all eDMA modules in an SOC.  <a href="#ga7deb54a7e997d79de1ed7c4e85290688">More...</a><br/></td></tr>
<tr class="separator:ga7deb54a7e997d79de1ed7c4e85290688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a4960bfad9f247d14b59041415dbc3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__edma__hal.html#gab6319bfbfaebd007f7871ae5be5eebe4">edma_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__edma__driver.html#ga3a4960bfad9f247d14b59041415dbc3a">EDMA_DRV_Deinit</a> (void)</td></tr>
<tr class="memdesc:ga3a4960bfad9f247d14b59041415dbc3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shuts down all eDMA modules.  <a href="#ga3a4960bfad9f247d14b59041415dbc3a">More...</a><br/></td></tr>
<tr class="separator:ga3a4960bfad9f247d14b59041415dbc3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
eDMA peripheral driver channel management functions</h2></td></tr>
<tr class="memitem:ga447c2ba3ddc2f7539d9dcd643ee2cc6d"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__edma__driver.html#ga447c2ba3ddc2f7539d9dcd643ee2cc6d">EDMA_DRV_RequestChannel</a> (uint8_t channel, dma_request_source_t source, <a class="el" href="group__edma__driver.html#structedma__chn__state__t">edma_chn_state_t</a> *chn)</td></tr>
<tr class="memdesc:ga447c2ba3ddc2f7539d9dcd643ee2cc6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests an eDMA channel dynamically or statically.  <a href="#ga447c2ba3ddc2f7539d9dcd643ee2cc6d">More...</a><br/></td></tr>
<tr class="separator:ga447c2ba3ddc2f7539d9dcd643ee2cc6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20385ab2bc82696e334dabcb00e670c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__edma__hal.html#gab6319bfbfaebd007f7871ae5be5eebe4">edma_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__edma__driver.html#ga20385ab2bc82696e334dabcb00e670c0">EDMA_DRV_ReleaseChannel</a> (<a class="el" href="group__edma__driver.html#structedma__chn__state__t">edma_chn_state_t</a> *chn)</td></tr>
<tr class="memdesc:ga20385ab2bc82696e334dabcb00e670c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases an eDMA channel.  <a href="#ga20385ab2bc82696e334dabcb00e670c0">More...</a><br/></td></tr>
<tr class="separator:ga20385ab2bc82696e334dabcb00e670c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
eDMA peripheral driver transfer setup functions</h2></td></tr>
<tr class="memitem:ga09a0300eac8bc8a616937b80cd98489e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__edma__hal.html#gab6319bfbfaebd007f7871ae5be5eebe4">edma_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__edma__driver.html#ga09a0300eac8bc8a616937b80cd98489e">EDMA_DRV_PrepareDescriptorTransfer</a> (<a class="el" href="group__edma__driver.html#structedma__chn__state__t">edma_chn_state_t</a> *chn, <a class="el" href="group__edma__hal.html#structedma__software__tcd__t">edma_software_tcd_t</a> *stcd, <a class="el" href="group__edma__hal.html#structedma__transfer__config__t">edma_transfer_config_t</a> *config, bool enableInt, bool disableDmaRequest)</td></tr>
<tr class="memdesc:ga09a0300eac8bc8a616937b80cd98489e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the descriptor basic transfer for the descriptor.  <a href="#ga09a0300eac8bc8a616937b80cd98489e">More...</a><br/></td></tr>
<tr class="separator:ga09a0300eac8bc8a616937b80cd98489e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e3d50233ea8b0e3879c4f51cd15d1c9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__edma__hal.html#gab6319bfbfaebd007f7871ae5be5eebe4">edma_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__edma__driver.html#ga9e3d50233ea8b0e3879c4f51cd15d1c9">EDMA_DRV_PrepareDescriptorScatterGather</a> (<a class="el" href="group__edma__hal.html#structedma__software__tcd__t">edma_software_tcd_t</a> *stcd, <a class="el" href="group__edma__hal.html#structedma__software__tcd__t">edma_software_tcd_t</a> *nextStcd)</td></tr>
<tr class="memdesc:ga9e3d50233ea8b0e3879c4f51cd15d1c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the memory address for the next transfer TCD for the software TCD.  <a href="#ga9e3d50233ea8b0e3879c4f51cd15d1c9">More...</a><br/></td></tr>
<tr class="separator:ga9e3d50233ea8b0e3879c4f51cd15d1c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabaf1b34ac08208964eb0c9b6a73a4e79"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__edma__hal.html#gab6319bfbfaebd007f7871ae5be5eebe4">edma_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__edma__driver.html#gabaf1b34ac08208964eb0c9b6a73a4e79">EDMA_DRV_PrepareDescriptorChannelLink</a> (<a class="el" href="group__edma__hal.html#structedma__software__tcd__t">edma_software_tcd_t</a> *stcd, uint32_t linkChn)</td></tr>
<tr class="memdesc:gabaf1b34ac08208964eb0c9b6a73a4e79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the major channel link the software TCD.  <a href="#gabaf1b34ac08208964eb0c9b6a73a4e79">More...</a><br/></td></tr>
<tr class="separator:gabaf1b34ac08208964eb0c9b6a73a4e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41390e32e4a85b91201830a84a5fcd60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__edma__hal.html#gab6319bfbfaebd007f7871ae5be5eebe4">edma_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__edma__driver.html#ga41390e32e4a85b91201830a84a5fcd60">EDMA_DRV_PushDescriptorToReg</a> (<a class="el" href="group__edma__driver.html#structedma__chn__state__t">edma_chn_state_t</a> *chn, <a class="el" href="group__edma__hal.html#structedma__software__tcd__t">edma_software_tcd_t</a> *stcd)</td></tr>
<tr class="memdesc:ga41390e32e4a85b91201830a84a5fcd60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the software TCD configuration to the hardware TCD.  <a href="#ga41390e32e4a85b91201830a84a5fcd60">More...</a><br/></td></tr>
<tr class="separator:ga41390e32e4a85b91201830a84a5fcd60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cbe648d04e75b237eaa21f68fafa11c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__edma__hal.html#gab6319bfbfaebd007f7871ae5be5eebe4">edma_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__edma__driver.html#ga2cbe648d04e75b237eaa21f68fafa11c">EDMA_DRV_ConfigLoopTransfer</a> (<a class="el" href="group__edma__driver.html#structedma__chn__state__t">edma_chn_state_t</a> *chn, <a class="el" href="group__edma__hal.html#structedma__software__tcd__t">edma_software_tcd_t</a> *stcd, <a class="el" href="group__edma__driver.html#ga7803399034b374663f76a589da7d8419">edma_transfer_type_t</a> type, uint32_t srcAddr, uint32_t destAddr, uint32_t size, uint32_t bytesOnEachRequest, uint32_t totalLength, uint8_t number)</td></tr>
<tr class="memdesc:ga2cbe648d04e75b237eaa21f68fafa11c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the DMA transfer in a scatter-gather mode.  <a href="#ga2cbe648d04e75b237eaa21f68fafa11c">More...</a><br/></td></tr>
<tr class="separator:ga2cbe648d04e75b237eaa21f68fafa11c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33c27d831a0a4e6374076278b85d4a67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__edma__hal.html#gab6319bfbfaebd007f7871ae5be5eebe4">edma_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__edma__driver.html#ga33c27d831a0a4e6374076278b85d4a67">EDMA_DRV_ConfigScatterGatherTransfer</a> (<a class="el" href="group__edma__driver.html#structedma__chn__state__t">edma_chn_state_t</a> *chn, <a class="el" href="group__edma__hal.html#structedma__software__tcd__t">edma_software_tcd_t</a> *stcd, <a class="el" href="group__edma__driver.html#ga7803399034b374663f76a589da7d8419">edma_transfer_type_t</a> type, uint32_t size, uint32_t bytesOnEachRequest, <a class="el" href="group__edma__driver.html#structedma__scatter__gather__list__t">edma_scatter_gather_list_t</a> *srcList, <a class="el" href="group__edma__driver.html#structedma__scatter__gather__list__t">edma_scatter_gather_list_t</a> *destList, uint8_t number)</td></tr>
<tr class="memdesc:ga33c27d831a0a4e6374076278b85d4a67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the DMA transfer in a scatter-gather mode.  <a href="#ga33c27d831a0a4e6374076278b85d4a67">More...</a><br/></td></tr>
<tr class="separator:ga33c27d831a0a4e6374076278b85d4a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
eDMA peripheral driver channel operation functions</h2></td></tr>
<tr class="memitem:gae5dc17a0595a4e27b4877edea7549ece"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__edma__hal.html#gab6319bfbfaebd007f7871ae5be5eebe4">edma_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__edma__driver.html#gae5dc17a0595a4e27b4877edea7549ece">EDMA_DRV_StartChannel</a> (<a class="el" href="group__edma__driver.html#structedma__chn__state__t">edma_chn_state_t</a> *chn)</td></tr>
<tr class="memdesc:gae5dc17a0595a4e27b4877edea7549ece"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts an eDMA channel.  <a href="#gae5dc17a0595a4e27b4877edea7549ece">More...</a><br/></td></tr>
<tr class="separator:gae5dc17a0595a4e27b4877edea7549ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0b33587b9f7ab6321c5e390564d0aa7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__edma__hal.html#gab6319bfbfaebd007f7871ae5be5eebe4">edma_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__edma__driver.html#gaf0b33587b9f7ab6321c5e390564d0aa7">EDMA_DRV_StopChannel</a> (<a class="el" href="group__edma__driver.html#structedma__chn__state__t">edma_chn_state_t</a> *chn)</td></tr>
<tr class="memdesc:gaf0b33587b9f7ab6321c5e390564d0aa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops the eDMA channel.  <a href="#gaf0b33587b9f7ab6321c5e390564d0aa7">More...</a><br/></td></tr>
<tr class="separator:gaf0b33587b9f7ab6321c5e390564d0aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
eDMA peripheral callback and interrupt functions</h2></td></tr>
<tr class="memitem:ga8bb06f10bb3021e9847cea985f787301"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__edma__hal.html#gab6319bfbfaebd007f7871ae5be5eebe4">edma_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__edma__driver.html#ga8bb06f10bb3021e9847cea985f787301">EDMA_DRV_InstallCallback</a> (<a class="el" href="group__edma__driver.html#structedma__chn__state__t">edma_chn_state_t</a> *chn, <a class="el" href="group__edma__driver.html#gab79e6ce110f65567abad8afb7dd94309">edma_callback_t</a> callback, void *parameter)</td></tr>
<tr class="memdesc:ga8bb06f10bb3021e9847cea985f787301"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers the callback function and the parameter for eDMA channel.  <a href="#ga8bb06f10bb3021e9847cea985f787301">More...</a><br/></td></tr>
<tr class="separator:ga8bb06f10bb3021e9847cea985f787301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64bd6fed67de6dfd3ac084643077b083"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__edma__driver.html#ga64bd6fed67de6dfd3ac084643077b083">EDMA_DRV_IRQHandler</a> (uint8_t channel)</td></tr>
<tr class="memdesc:ga64bd6fed67de6dfd3ac084643077b083"><td class="mdescLeft">&#160;</td><td class="mdescRight">IRQ Handler for eDMA channel interrupt.  <a href="#ga64bd6fed67de6dfd3ac084643077b083">More...</a><br/></td></tr>
<tr class="separator:ga64bd6fed67de6dfd3ac084643077b083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab93343849db92e0d475d731358c1b8c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__edma__driver.html#gab93343849db92e0d475d731358c1b8c2">EDMA_DRV_ErrorIRQHandler</a> (uint8_t instance)</td></tr>
<tr class="memdesc:gab93343849db92e0d475d731358c1b8c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">ERROR IRQ Handler for eDMA channel interrupt.  <a href="#gab93343849db92e0d475d731358c1b8c2">More...</a><br/></td></tr>
<tr class="separator:gab93343849db92e0d475d731358c1b8c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
eDMA peripheral driver misc functions</h2></td></tr>
<tr class="memitem:gac2e2a0e878dee3214d75aae65b4371f7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__edma__driver.html#ga10b6a19b129232cb5dbbb2b320c9c224">edma_chn_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__edma__driver.html#gac2e2a0e878dee3214d75aae65b4371f7">EDMA_DRV_GetChannelStatus</a> (<a class="el" href="group__edma__driver.html#structedma__chn__state__t">edma_chn_state_t</a> *chn)</td></tr>
<tr class="memdesc:gac2e2a0e878dee3214d75aae65b4371f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the eDMA channel status.  <a href="#gac2e2a0e878dee3214d75aae65b4371f7">More...</a><br/></td></tr>
<tr class="separator:gac2e2a0e878dee3214d75aae65b4371f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88c4c3f2acddd4cfb242fcfb6aba073d"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__edma__driver.html#ga88c4c3f2acddd4cfb242fcfb6aba073d">EDMA_DRV_GetFinishedBytes</a> (<a class="el" href="group__edma__driver.html#structedma__chn__state__t">edma_chn_state_t</a> *chn)</td></tr>
<tr class="memdesc:ga88c4c3f2acddd4cfb242fcfb6aba073d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the bytes already transferred for eDMA channel current TCD.  <a href="#ga88c4c3f2acddd4cfb242fcfb6aba073d">More...</a><br/></td></tr>
<tr class="separator:ga88c4c3f2acddd4cfb242fcfb6aba073d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>


<h3><a class="anchor" id="edma_driver"></a>eDMA Peripheral Driver</h3><div class="textblock"><h1>Overview</h1>
The eDMA driver requests, configures, and uses eDMA hardware. It supports module initializations and DMA channel configurations. <br/>
 </p>
<h1>Initialization</h1>
To initialize the DMA module, call the <a class="el" href="group__edma__driver.html#ga7deb54a7e997d79de1ed7c4e85290688" title="Initializes all eDMA modules in an SOC. ">EDMA_DRV_Init()</a> function. The user does not need to pass a configuration data structure. This function enables the eDMA module and clock automatically. <br/>
 </p>
<h1>Channel concept</h1>
The eDMA module has many channels. Additionally, the EDMA peripheral driver is designed based on a channel concept. All operations should be started by requesting an eDMA channel and ended by freeing an eDMA channel. The user can configure and run operations on the eDMA module by allocating a channel. If a channel is not allocated, a system error may occur. <br/>
 </p>
<h1>DMA request concept</h1>
A DMA request is used to trigger an eDMA transfer. The DMA request table is available in chip configuration chapters in each chip reference manual.<h1>Memory allocation and alignment</h1>
The eDMA peripheral driver does not allocate any memory dynamically. The user needs to provide the allocated memory pointer for the driver and ensure that the memory is valid. If this is not done, a system error may occur. The user needs to prepare three types of memory:</p>
<ol type="1">
<li>The handler memory: [edma_channel_t]. The driver must store the status data for each channel and the edma_channel_t is designed for this purpose.</li>
<li>The <a class="el" href="group__edma__hal.html#structedma__software__tcd__t" title="eDMA TCD ">edma_software_tcd_t</a>. The eDMA supports a TCD chain, which provides either the scatter-gather feature or the loop feature. The eDMA module loads the TCDCs from memory, where TCDs are stored. The user must provide the memory storing software TCDs and the <a class="el" href="group__edma__driver.html#ga33c27d831a0a4e6374076278b85d4a67" title="Configures the DMA transfer in a scatter-gather mode. ">EDMA_DRV_ConfigScatterGatherTransfer()</a> function or the <a class="el" href="group__edma__driver.html#ga2cbe648d04e75b237eaa21f68fafa11c" title="Configures the DMA transfer in a scatter-gather mode. ">EDMA_DRV_ConfigLoopTransfer()</a> function to configure the software TCDs. If those functions fail to configure the software TCDs, use the <a class="el" href="group__edma__driver.html#ga09a0300eac8bc8a616937b80cd98489e" title="Sets the descriptor basic transfer for the descriptor. ">EDMA_DRV_PrepareDescriptorTransfer()</a> function to configure the TCD. Then, call the <a class="el" href="group__edma__driver.html#ga41390e32e4a85b91201830a84a5fcd60" title="Copies the software TCD configuration to the hardware TCD. ">EDMA_DRV_PushDescriptorToReg()</a> function to push the TCD to registers.</li>
<li>The status memory. If the user wants to know the status of TCD chains, the user needs to provide the status memory and the driver will fill it with the chain status. <br/>
 The start address of the software TCDs must be 32 bytes. <br/>
 <h1>Call diagram</h1>
</li>
</ol>
To use the DMA driver, follow these steps:</p>
<ol type="1">
<li>Initialize the DMA module: <a class="el" href="group__edma__driver.html#ga7deb54a7e997d79de1ed7c4e85290688" title="Initializes all eDMA modules in an SOC. ">EDMA_DRV_Init()</a>.</li>
<li>Request a DMA channel: <a class="el" href="group__edma__driver.html#ga447c2ba3ddc2f7539d9dcd643ee2cc6d" title="Requests an eDMA channel dynamically or statically. ">EDMA_DRV_RequestChannel()</a>.</li>
<li>Configure the TCD:<ul>
<li>Configure the TCD chain in a scatter-gather list. UART transmit/receive is the common case.</li>
<li>Configure the TCD chain in a loop way. Audio playback/Record is the common case.</li>
<li>Configure software TCD and push it to registers. Use the DSPI case to configure and push the TCD to registers.</li>
</ul>
</li>
<li>Register callback function: EDMA_DRV_InstallCallback.</li>
<li>Start the DMA channel: EDMA_DRV_StartChannel.</li>
<li>[OPTION] Stop the DMA channel: EDMA_DRV_StopChannel.</li>
<li>Free the DMA channel: EDMA_DRV_ReleaseChannel.</li>
</ol>
This is an example code to initialize and configure the driver by configuring the descriptor:<div class="fragment"><div class="line"><a class="code" href="group__edma__driver.html#ga7deb54a7e997d79de1ed7c4e85290688">EDMA_DRV_Init</a>();</div>
<div class="line"></div>
<div class="line">stcd = (<a class="code" href="group__edma__hal.html#structedma__software__tcd__t">edma_software_tcd_t</a> *)(((uint32_t)status + 32) &amp; ~0x1F); </div>
<div class="line"></div>
<div class="line"><span class="comment">/* Prepare the memory space. */</span></div>
<div class="line"><span class="keywordflow">for</span> ( i = 0; i &lt; kEdmaTestChainLength; i++)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* Allocate the memory! */</span></div>
<div class="line">    srcAddr[i] = malloc(kEdmaTestBufferSize); </div>
<div class="line">    destAddr[i] = malloc(kEdmaTestBufferSize); </div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Check whether the allocation is successfully. */</span></div>
<div class="line">    <span class="keywordflow">if</span> (((uint32_t)srcAddr[i] == 0x0U) &amp; ((uint32_t)destAddr[i] == 0x0U)) </div>
<div class="line">    {</div>
<div class="line">        printf(<span class="stringliteral">&quot;Fali to allocate memory for EDMA test! \r\n&quot;</span>);</div>
<div class="line">        <span class="keywordflow">goto</span> error;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Init the memory buffer. */</span></div>
<div class="line">    <span class="keywordflow">for</span> (j = 0; j &lt; kEdmaTestBufferSize; j++)</div>
<div class="line">    {</div>
<div class="line">        srcAddr[i][j] = j;</div>
<div class="line">        destAddr[i][j] = 0;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    srcSG[i].address = (uint32_t)srcAddr[i];</div>
<div class="line">    destSG[i].address = (uint32_t)destAddr[i];</div>
<div class="line">    srcSG[i].length = kEdmaTestBufferSize;</div>
<div class="line">    destSG[i].length = kEdmaTestBufferSize;</div>
<div class="line"></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="group__edma__driver.html#ga447c2ba3ddc2f7539d9dcd643ee2cc6d">EDMA_DRV_RequestChannel</a>(channel, kDmaRequestMux0AlwaysOn62, &amp;chan_handler) != channel)</div>
<div class="line">{</div>
<div class="line">    printf(<span class="stringliteral">&quot;Failed to request channel %d !\r\n&quot;</span>, channel);</div>
<div class="line">    <span class="keywordflow">goto</span> error;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__edma__driver.html#ga33c27d831a0a4e6374076278b85d4a67">EDMA_DRV_ConfigScatterGatherTransfer</a>(</div>
<div class="line">        stcd, &amp;chan_handler, <a class="code" href="group__dma__hal.html#gga9cb7087af6efc80106c1033f80d60219aff39b9c9f7450a5f608b901a0cd5c535">kDmaMemoryToMemory</a>, </div>
<div class="line">        0x1U, kEdmaTestWatermarkLevel,</div>
<div class="line">        srcSG, destSG,</div>
<div class="line">        kEdmaTestChainLength);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__edma__driver.html#ga8bb06f10bb3021e9847cea985f787301">EDMA_DRV_InstallCallback</a>(&amp;chan_handler, test_callback, &amp;chan_handler);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__edma__driver.html#gae5dc17a0595a4e27b4877edea7549ece">EDMA_DRV_StartChannel</a>(&amp;chan_handler);</div>
</div><!-- fragment -->For an example to configure the loop mode, see the SAI module driver.<h1>Extend the driver</h1>
The user can call the eDMA HAL driver to extend the application capability. </div><hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structedma__user__config__t" id="structedma__user__config__t"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct edma_user_config_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Use an instance of this structure with the <a class="el" href="group__edma__driver.html#ga7deb54a7e997d79de1ed7c4e85290688" title="Initializes all eDMA modules in an SOC. ">EDMA_DRV_Init()</a> function. This allows the user to configure settings of the EDMA peripheral with a single function call. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:af6a9367e435cdcc1a239a7ccbd38aa13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__edma__hal.html#ga1ae691e6c3e3af80d079f01dc4e0d9d9">edma_channel_arbitration_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__edma__driver.html#af6a9367e435cdcc1a239a7ccbd38aa13">chnArbitration</a></td></tr>
<tr class="memdesc:af6a9367e435cdcc1a239a7ccbd38aa13"><td class="mdescLeft">&#160;</td><td class="mdescRight">eDMA channel arbitration.  <a href="#af6a9367e435cdcc1a239a7ccbd38aa13">More...</a><br/></td></tr>
<tr class="separator:af6a9367e435cdcc1a239a7ccbd38aa13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d0df54ed2a5b6840db6a279d6ba9066"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d0df54ed2a5b6840db6a279d6ba9066"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>notHaltOnError</b></td></tr>
<tr class="separator:a3d0df54ed2a5b6840db6a279d6ba9066"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Field Documentation</h4>
<a class="anchor" id="af6a9367e435cdcc1a239a7ccbd38aa13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__edma__hal.html#ga1ae691e6c3e3af80d079f01dc4e0d9d9">edma_channel_arbitration_t</a> edma_user_config_t::chnArbitration</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>

</div>
</div>
<a name="structedma__chn__state__t" id="structedma__chn__state__t"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct edma_chn_state_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:a36a488cb5646ae23e1cd27fa4c898f0c"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__edma__driver.html#a36a488cb5646ae23e1cd27fa4c898f0c">channel</a></td></tr>
<tr class="memdesc:a36a488cb5646ae23e1cd27fa4c898f0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual channel indicator.  <a href="#a36a488cb5646ae23e1cd27fa4c898f0c">More...</a><br/></td></tr>
<tr class="separator:a36a488cb5646ae23e1cd27fa4c898f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd9d3f19806732ca4e66028bd5145ed8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__edma__driver.html#gab79e6ce110f65567abad8afb7dd94309">edma_callback_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__edma__driver.html#abd9d3f19806732ca4e66028bd5145ed8">callback</a></td></tr>
<tr class="memdesc:abd9d3f19806732ca4e66028bd5145ed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function pointer for the eDMA channel.  <a href="#abd9d3f19806732ca4e66028bd5145ed8">More...</a><br/></td></tr>
<tr class="separator:abd9d3f19806732ca4e66028bd5145ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae506339c8a30928848bedfa85f05169"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__edma__driver.html#aae506339c8a30928848bedfa85f05169">parameter</a></td></tr>
<tr class="memdesc:aae506339c8a30928848bedfa85f05169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter for the callback function pointer.  <a href="#aae506339c8a30928848bedfa85f05169">More...</a><br/></td></tr>
<tr class="separator:aae506339c8a30928848bedfa85f05169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5399b860ee024d8a672d7e539109ae17"><td class="memItemLeft" align="right" valign="top">volatile <a class="el" href="group__edma__driver.html#ga10b6a19b129232cb5dbbb2b320c9c224">edma_chn_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__edma__driver.html#a5399b860ee024d8a672d7e539109ae17">status</a></td></tr>
<tr class="memdesc:a5399b860ee024d8a672d7e539109ae17"><td class="mdescLeft">&#160;</td><td class="mdescRight">eDMA channel status.  <a href="#a5399b860ee024d8a672d7e539109ae17">More...</a><br/></td></tr>
<tr class="separator:a5399b860ee024d8a672d7e539109ae17"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Field Documentation</h4>
<a class="anchor" id="a36a488cb5646ae23e1cd27fa4c898f0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t edma_chn_state_t::channel</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abd9d3f19806732ca4e66028bd5145ed8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__edma__driver.html#gab79e6ce110f65567abad8afb7dd94309">edma_callback_t</a> edma_chn_state_t::callback</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>It will be called at the eDMA channel complete and eDMA channel error. </p>

</div>
</div>
<a class="anchor" id="aae506339c8a30928848bedfa85f05169"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* edma_chn_state_t::parameter</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5399b860ee024d8a672d7e539109ae17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile <a class="el" href="group__edma__driver.html#ga10b6a19b129232cb5dbbb2b320c9c224">edma_chn_status_t</a> edma_chn_state_t::status</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>

</div>
</div>
<a name="structedma__scatter__gather__list__t" id="structedma__scatter__gather__list__t"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct edma_scatter_gather_list_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:aaef294d34d3639dc86866729b7ee7371"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__edma__driver.html#aaef294d34d3639dc86866729b7ee7371">address</a></td></tr>
<tr class="memdesc:aaef294d34d3639dc86866729b7ee7371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Address of buffer.  <a href="#aaef294d34d3639dc86866729b7ee7371">More...</a><br/></td></tr>
<tr class="separator:aaef294d34d3639dc86866729b7ee7371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde676116023ca67b108ff22b777980f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__edma__driver.html#adde676116023ca67b108ff22b777980f">length</a></td></tr>
<tr class="memdesc:adde676116023ca67b108ff22b777980f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Length of buffer.  <a href="#adde676116023ca67b108ff22b777980f">More...</a><br/></td></tr>
<tr class="separator:adde676116023ca67b108ff22b777980f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Field Documentation</h4>
<a class="anchor" id="aaef294d34d3639dc86866729b7ee7371"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t edma_scatter_gather_list_t::address</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="adde676116023ca67b108ff22b777980f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t edma_scatter_gather_list_t::length</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>

</div>
</div>
<a name="structedma__state__t" id="structedma__state__t"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct edma_state_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>This structure holds data that is used by the eDMA peripheral driver to manage multi eDMA channels. The user must pass the memory for this run-time state structure and the eDMA driver fills out the members. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:a4cd4993b52b9f2d9e080571817e446c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__edma__driver.html#structedma__chn__state__t">edma_chn_state_t</a> *volatile&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__edma__driver.html#a4cd4993b52b9f2d9e080571817e446c0">chn</a> [FSL_FEATURE_EDMA_DMAMUX_CHANNELS]</td></tr>
<tr class="memdesc:a4cd4993b52b9f2d9e080571817e446c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer array storing channel state.  <a href="#a4cd4993b52b9f2d9e080571817e446c0">More...</a><br/></td></tr>
<tr class="separator:a4cd4993b52b9f2d9e080571817e446c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Field Documentation</h4>
<a class="anchor" id="a4cd4993b52b9f2d9e080571817e446c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__edma__driver.html#structedma__chn__state__t">edma_chn_state_t</a>* volatile edma_state_t::chn[FSL_FEATURE_EDMA_DMAMUX_CHANNELS]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>

</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga7f0960bc8b86ebdf70632f839e914832"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STCD_SIZE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">number</td><td>)</td>
          <td>&#160;&#160;&#160;((number + 1) * 32)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Software TCD is aligned to 32 bytes. To make sure the software TCD can meet the eDMA module's requirement, allocate memory with extra 32 bytes. </p>

</div>
</div>
<a class="anchor" id="ga2153971dae04c6beaa8f793ba70b6700"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VIRTUAL_CHN_TO_EDMA_MODULE_REGBASE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">chn</td><td>)</td>
          <td>&#160;&#160;&#160;g_edmaBaseAddr[chn/FSL_FEATURE_EDMA_MODULE_CHANNEL]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga92d18817e1451a961d81c8d4357501d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VIRTUAL_CHN_TO_EDMA_CHN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">chn</td><td>)</td>
          <td>&#160;&#160;&#160;(chn%FSL_FEATURE_EDMA_MODULE_CHANNEL)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga5dea015770302df2f22a45a07104ec2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VIRTUAL_CHN_TO_DMAMUX_MODULE_REGBASE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">chn</td><td>)</td>
          <td>&#160;&#160;&#160;g_dmamuxBaseAddr[chn/FSL_FEATURE_DMAMUX_MODULE_CHANNEL]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga46e69802a3047dce07c1075d7049b3a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VIRTUAL_CHN_TO_DMAMUX_CHN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">chn</td><td>)</td>
          <td>&#160;&#160;&#160;(chn%FSL_FEATURE_DMAMUX_MODULE_CHANNEL)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="gab79e6ce110f65567abad8afb7dd94309"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* edma_callback_t)(void *parameter, <a class="el" href="group__edma__driver.html#ga10b6a19b129232cb5dbbb2b320c9c224">edma_chn_status_t</a> status)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prototype for the callback function registered in the eDMA driver. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga10b6a19b129232cb5dbbb2b320c9c224"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__edma__driver.html#ga10b6a19b129232cb5dbbb2b320c9c224">edma_chn_status_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A structure describing the eDMA channel status. The user can get the status by callback parameter or by calling EDMA_DRV_getStatus(). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga10b6a19b129232cb5dbbb2b320c9c224a048d8fdbd086fe00875c1c1eaa5776de"></a>kEDMAChnNormal</em>&nbsp;</td><td class="fielddoc">
<p>eDMA channel is occupied. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga10b6a19b129232cb5dbbb2b320c9c224adf8d761a4dfef11c2c96503642e292d7"></a>kEDMAChnIdle</em>&nbsp;</td><td class="fielddoc">
<p>eDMA channel is idle. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga10b6a19b129232cb5dbbb2b320c9c224a6e48551773d676e0b0a654f49e8240c5"></a>kEDMAChnError</em>&nbsp;</td><td class="fielddoc">
<p>An error occurs in the eDMA channel. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gaf2953f24d4e77d2b48a81649b388e0c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__edma__driver.html#gaf2953f24d4e77d2b48a81649b388e0c9">edma_chn_state_type_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ggaf2953f24d4e77d2b48a81649b388e0c9a86bc626247a5202c28081d91d93fff07"></a>kEDMAInvalidChannel</em>&nbsp;</td><td class="fielddoc">
<p>Macros indicate the failure of the channel request. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggaf2953f24d4e77d2b48a81649b388e0c9a23ba047d4c39c222968ee427f13f0b30"></a>kEDMAAnyChannel</em>&nbsp;</td><td class="fielddoc">
<p>Macros used when requesting channel dynamically. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga7803399034b374663f76a589da7d8419"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__edma__driver.html#ga7803399034b374663f76a589da7d8419">edma_transfer_type_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga7803399034b374663f76a589da7d8419ae94ab12f5f1047bb1d6d7ac7138a0b76"></a>kEDMAPeripheralToMemory</em>&nbsp;</td><td class="fielddoc">
<p>Transfer from peripheral to memory. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga7803399034b374663f76a589da7d8419a7439f8629c412b13978697220830e862"></a>kEDMAMemoryToPeripheral</em>&nbsp;</td><td class="fielddoc">
<p>Transfer from memory to peripheral. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga7803399034b374663f76a589da7d8419aefd101c1a4783b9efa6595cff7ddea7b"></a>kEDMAMemoryToMemory</em>&nbsp;</td><td class="fielddoc">
<p>Transfer from memory to memory. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga7deb54a7e997d79de1ed7c4e85290688"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__edma__hal.html#gab6319bfbfaebd007f7871ae5be5eebe4">edma_status_t</a> EDMA_DRV_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__edma__driver.html#structedma__state__t">edma_state_t</a> *&#160;</td>
          <td class="paramname"><em>edmaState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__edma__driver.html#structedma__user__config__t">edma_user_config_t</a> *&#160;</td>
          <td class="paramname"><em>userConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function initializes the run-time state structure to provide the eDMA channel allocation release, protect, and track the state for channels. This function also opens the clock to the eDMA modules, resets the eDMA modules, initializes the module to user-defined settings and default settings. This is an example to set up the <a class="el" href="group__edma__driver.html#structedma__state__t" title="Runtime state structure for the eDMA driver. ">edma_state_t</a> and the <a class="el" href="group__edma__driver.html#structedma__user__config__t" title="The user configuration structure for the eDMA driver. ">edma_user_config_t</a> parameters and to call the EDMA_DRV_Init function by passing in these parameters. </p>
<div class="fragment"><div class="line">   <a class="code" href="group__edma__driver.html#structedma__state__t">edma_state_t</a> state;    &lt;- The user simply allocates memory <span class="keywordflow">for</span> <span class="keyword">this</span> structure.</div>
<div class="line">   <a class="code" href="group__edma__driver.html#structedma__user__config__t">edma_user_config_t</a> userConfig;    &lt;- The user fills out members <span class="keywordflow">for</span> <span class="keyword">this</span> structure.</div>
<div class="line"></div>
<div class="line">   userConfig.<a class="code" href="group__edma__driver.html#af6a9367e435cdcc1a239a7ccbd38aa13">chnArbitration</a> = <a class="code" href="group__edma__hal.html#gga1ae691e6c3e3af80d079f01dc4e0d9d9acb97728581b710ac5b456c4f52e4b9ad">kEDMAChnArbitrationRoundrobin</a>;</div>
<div class="line"><span class="preprocessor">#if (FSL_FEATURE_EDMA_CHANNEL_GROUP_COUNT &gt; 0x1U)</span></div>
<div class="line"><span class="preprocessor"></span>   <span class="comment">//configuration for 2 lines below only valid for SoCs with more than on group.</span></div>
<div class="line">   userConfig.groupArbitration = kEDMAGroupArbitrationFixedPriority;</div>
<div class="line">   userConfig.groupPriority = kEDMAGroup0PriorityHighGroup1PriorityLow;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span>   userCOnfig.notHaltOnError = <span class="keyword">false</span>;    &lt;- The <span class="keywordflow">default</span> setting is <span class="keyword">false</span>, means eDMA halt on error.</div>
<div class="line"></div>
<div class="line">   <a class="code" href="group__edma__driver.html#ga7deb54a7e997d79de1ed7c4e85290688">EDMA_DRV_Init</a>(&amp;state, &amp;userConfig);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edmaState</td><td>The pointer to the eDMA peripheral driver state structure. The user must pass the memory for this run-time state structure and the eDMA peripheral driver will fill out the members. This run-time state structure keeps track of the eDMA channels status. The memory must be kept valid before calling the EDMA_DRV_DeInit. </td></tr>
    <tr><td class="paramname">userConfig</td><td>User configuration structure for eDMA peripheral drivers. The user must fill out the members of this structure and pass the pointer of this structure into the function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An eDMA error codes or kStatus_EDMA_Success. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3a4960bfad9f247d14b59041415dbc3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__edma__hal.html#gab6319bfbfaebd007f7871ae5be5eebe4">edma_status_t</a> EDMA_DRV_Deinit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function resets the eDMA modules to reset state, gates the clock, and disables the interrupt to the core.</p>
<dl class="section return"><dt>Returns</dt><dd>An eDMA error codes or kStatus_EDMA_Success. </dd></dl>

</div>
</div>
<a class="anchor" id="ga447c2ba3ddc2f7539d9dcd643ee2cc6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t EDMA_DRV_RequestChannel </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dma_request_source_t&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__edma__driver.html#structedma__chn__state__t">edma_chn_state_t</a> *&#160;</td>
          <td class="paramname"><em>chn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function allocates eDMA channel according to the required channel allocation and corresponding to the eDMA hardware request, initializes the channel state memory provided by user and fills out the members. This functions also sets up the hardware request configuration according to the user.</p>
<p>For Kinetis SOC, a hardware request can be mapped to eDMA channels and used for the channel trigger. Some hardware requests can only be mapped to a limited channels. For example, the Kinetis K70FN1M0VMJ15 SOC eDMA module has 2 eDMA channel groups. The first group consists of the channel 0 - 15. The second group consists of channel 16 - 31. The hardware request UART0-Receive can be only mapped to group 1. Therefore, the hardware request is one of the parameter that the user needs to provide for the channel request. Channel needn't be triggered by the peripheral hardware request. The user can provide the ALWAYSON type hardware request to trigger the channel continuously.</p>
<p>This function provides two ways to allocate an eDMA channel: statically and dynamically. In a static allocation, the user provides the required channel number and eDMA driver tries to allocate the required channel to the user. If the channel is not occupied, the eDMA driver is successfully assigned to the user. If the channel is already occupied, the user gets the return value kEDMAInvalidChn. This is an example to request a channel in a static way: </p>
<div class="fragment"><div class="line">uint32_t channelNumber = 14;  &lt;- Try to allocate the channel 14</div>
<div class="line"><a class="code" href="group__edma__driver.html#structedma__chn__state__t">edma_chn_state_t</a> chn; &lt;- The user simply allocates memory <span class="keywordflow">for</span> <span class="keyword">this</span> structure.</div>
<div class="line"></div>
<div class="line">if ( <a class="code" href="group__edma__driver.html#ggaf2953f24d4e77d2b48a81649b388e0c9a86bc626247a5202c28081d91d93fff07">kEDMAInvalidChannel</a> == <a class="code" href="group__edma__driver.html#ga447c2ba3ddc2f7539d9dcd643ee2cc6d">EDMA_DRV_RequestChannel</a>(channel, kDmaRequestMux0AlwaysOn54, chn))</div>
<div class="line">{</div>
<div class="line">    printf(<span class="stringliteral">&quot;request channel %d failed!\n&quot;</span>, channel);</div>
<div class="line">}</div>
</div><!-- fragment --><p> In a dynamic allocation, any of the free eDMA channels are available for use. eDMA driver assigns the first free channel to the user. This is an example for user to request a channel dynamically : </p>
<div class="fragment"><div class="line">uint32_t channel;    &lt;- Store the allocated channel number.</div>
<div class="line">edma_chn_state_t chn;    &lt;- The user simply allocates memory <span class="keywordflow">for</span> <span class="keyword">this</span> structure.</div>
<div class="line"></div>
<div class="line">channel = <a class="code" href="group__edma__driver.html#ga447c2ba3ddc2f7539d9dcd643ee2cc6d">EDMA_DRV_RequestChannel</a>(<a class="code" href="group__edma__driver.html#ggaf2953f24d4e77d2b48a81649b388e0c9a23ba047d4c39c222968ee427f13f0b30">kEDMAAnyChannel</a>, kDmaRequestMux0AlwaysOn54, chn);</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">if</span> (channel == <a class="code" href="group__edma__driver.html#ggaf2953f24d4e77d2b48a81649b388e0c9a86bc626247a5202c28081d91d93fff07">kEDMAInvalidChannel</a>)</div>
<div class="line">{</div>
<div class="line">    printf(<span class="stringliteral">&quot;request channel %d failed!\n&quot;</span>, channel);</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">{</div>
<div class="line">    printf(<span class="stringliteral">&quot;Channel %d is successfully allocated! /n&quot;</span>, channel);</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Requested channel number. If the chn is assigned with the kEDMAAnyChannel, the eDMA driver allocates the channel dynamically. If the chn is assigned with a valid channel number, the eDMA driver allocates that channel. </td></tr>
    <tr><td class="paramname">source</td><td>eDMA hardware request number. </td></tr>
    <tr><td class="paramname">chn</td><td>The pointer to the eDMA channel state structure. The use must pass the memory for this run-time state structure and the eDMA peripheral driver fills out the members. This run-time state structure keeps tracks of the eDMA channel status. The memory must be kept valid before calling the <a class="el" href="group__edma__driver.html#ga20385ab2bc82696e334dabcb00e670c0" title="Releases an eDMA channel. ">EDMA_DRV_ReleaseChannel()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Successfully allocated channel number or the kEDMAInvalidChannel indicating that the request is failed. </dd></dl>

</div>
</div>
<a class="anchor" id="ga20385ab2bc82696e334dabcb00e670c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__edma__hal.html#gab6319bfbfaebd007f7871ae5be5eebe4">edma_status_t</a> EDMA_DRV_ReleaseChannel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__edma__driver.html#structedma__chn__state__t">edma_chn_state_t</a> *&#160;</td>
          <td class="paramname"><em>chn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function stops the eDMA channel and disables the interrupt of this channel. The channel state structure can be released after this function is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chn</td><td>The pointer to the channel state structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An eDMA error codes or kStatus_EDMA_Success. </dd></dl>

</div>
</div>
<a class="anchor" id="ga09a0300eac8bc8a616937b80cd98489e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__edma__hal.html#gab6319bfbfaebd007f7871ae5be5eebe4">edma_status_t</a> EDMA_DRV_PrepareDescriptorTransfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__edma__driver.html#structedma__chn__state__t">edma_chn_state_t</a> *&#160;</td>
          <td class="paramname"><em>chn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__edma__hal.html#structedma__software__tcd__t">edma_software_tcd_t</a> *&#160;</td>
          <td class="paramname"><em>stcd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__edma__hal.html#structedma__transfer__config__t">edma_transfer_config_t</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableInt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>disableDmaRequest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function sets up the basic transfer for the descriptor. The minor loop setting is not used because the minor loop configuration impacts the global eDMA setting. The source minor loop offset is relevant to the destination minor loop offset. For these reasons, the minor loop offset configuration is treated as an advanced configuration. The user can call the <a class="el" href="group__edma__hal.html#gac9d7aa8de4ddd8b488c19f7b947e0bbf" title="Configures the minorloop offset for the software TCD. ">EDMA_HAL_STCDSetMinorLoopOffset()</a> function to configure the minor loop offset feature.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Virtual channel number. </td></tr>
    <tr><td class="paramname">chn</td><td>The pointer to the channel state structure. </td></tr>
    <tr><td class="paramname">stcd</td><td>The pointer to the descriptor. </td></tr>
    <tr><td class="paramname">config</td><td>Configuration for the basic transfer. </td></tr>
    <tr><td class="paramname">enableInt</td><td>Enables (true) or Disables (false) interrupt on TCD complete. </td></tr>
    <tr><td class="paramname">disableDmaRequest</td><td>Disables (true) or Enable (false) DMA request on TCD complete. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9e3d50233ea8b0e3879c4f51cd15d1c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__edma__hal.html#gab6319bfbfaebd007f7871ae5be5eebe4">edma_status_t</a> EDMA_DRV_PrepareDescriptorScatterGather </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__edma__hal.html#structedma__software__tcd__t">edma_software_tcd_t</a> *&#160;</td>
          <td class="paramname"><em>stcd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__edma__hal.html#structedma__software__tcd__t">edma_software_tcd_t</a> *&#160;</td>
          <td class="paramname"><em>nextStcd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function enables the scatter/gather feature for the software TCD and configures the next TCD address.This address points to the beginning of a 0-modulo-32 byte region containing the next transfer TCD to be loaded into this channel. The channel reload is performed as the major iteration count completes. The scatter/gather address must be 0-modulo-32-byte. Otherwise, a configuration error is reported.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stcd</td><td>The pointer to the software TCD, which needs to link to the software TCD. The address needs to be aligned to 32 bytes. </td></tr>
    <tr><td class="paramname">nextStcd</td><td>The pointer to the software TCD, which is to be linked to the software TCD. The address needs to be aligned to 32 bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabaf1b34ac08208964eb0c9b6a73a4e79"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__edma__hal.html#gab6319bfbfaebd007f7871ae5be5eebe4">edma_status_t</a> EDMA_DRV_PrepareDescriptorChannelLink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__edma__hal.html#structedma__software__tcd__t">edma_software_tcd_t</a> *&#160;</td>
          <td class="paramname"><em>stcd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>linkChn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If the major link is enabled, after the major loop counter is exhausted, the eDMA engine initiates a channel service request at the channel defined by these six bits by setting that channel start bits.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stcd</td><td>The pointer to the software TCD. The address need to be aligned to 32 bytes. </td></tr>
    <tr><td class="paramname">linkChn</td><td>Channel number for major link </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga41390e32e4a85b91201830a84a5fcd60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__edma__hal.html#gab6319bfbfaebd007f7871ae5be5eebe4">edma_status_t</a> EDMA_DRV_PushDescriptorToReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__edma__driver.html#structedma__chn__state__t">edma_chn_state_t</a> *&#160;</td>
          <td class="paramname"><em>chn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__edma__hal.html#structedma__software__tcd__t">edma_software_tcd_t</a> *&#160;</td>
          <td class="paramname"><em>stcd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chn</td><td>The pointer to the channel state structure. </td></tr>
    <tr><td class="paramname">stcd</td><td>memory pointing to the software TCD. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2cbe648d04e75b237eaa21f68fafa11c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__edma__hal.html#gab6319bfbfaebd007f7871ae5be5eebe4">edma_status_t</a> EDMA_DRV_ConfigLoopTransfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__edma__driver.html#structedma__chn__state__t">edma_chn_state_t</a> *&#160;</td>
          <td class="paramname"><em>chn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__edma__hal.html#structedma__software__tcd__t">edma_software_tcd_t</a> *&#160;</td>
          <td class="paramname"><em>stcd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__edma__driver.html#ga7803399034b374663f76a589da7d8419">edma_transfer_type_t</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>destAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bytesOnEachRequest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>totalLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function configures the descriptors in a loop chain. The user passes a block of memory into this function and the memory is divided into the "period" sub blocks. The DMA driver configures the "period" descriptors. Each descriptor stands for a sub block. The DMA driver transfers data from the first descriptor to the last descriptor. Then, the DMA driver wraps to the first descriptor to continue the loop. The interrupt handler is called every time a descriptor is completed. The user can get a transfer status of a descriptor by calling the edma_get_descriptor_status() function in the interrupt handler or any other task context. At the same time, calling the edma_update_descriptor() function notifies the DMA driver that the content belonging to a descriptor is already updated and the DMA needs to count it as and underflow next time it loops to this descriptor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chn</td><td>The pointer to the channel state structure. </td></tr>
    <tr><td class="paramname">stcd</td><td>Memory pointing to software TCDs. The user must prepare this memory block. The required memory size is equal to a "period" * size of(edma_software_tcd_t). At the same time, the "stcd" must align with 32 bytes. If not, an error occurs in the eDMA driver. </td></tr>
    <tr><td class="paramname">type</td><td>Transfer type. </td></tr>
    <tr><td class="paramname">srcAddr</td><td>A source register address or a start memory address. </td></tr>
    <tr><td class="paramname">destAddr</td><td>A destination register address or a start memory address. </td></tr>
    <tr><td class="paramname">size</td><td>Size to be transferred on every DMA write/read. Source/Dest share the same write/read size. </td></tr>
    <tr><td class="paramname">bytesOnEachRequest</td><td>Size write/read for every trigger of the DMA request. </td></tr>
    <tr><td class="paramname">totalLength</td><td>Total length of Memory. </td></tr>
    <tr><td class="paramname">number</td><td>A number of the descriptor that is configured for this transfer configuration.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code of kStatus_EDMA_Success </dd></dl>

</div>
</div>
<a class="anchor" id="ga33c27d831a0a4e6374076278b85d4a67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__edma__hal.html#gab6319bfbfaebd007f7871ae5be5eebe4">edma_status_t</a> EDMA_DRV_ConfigScatterGatherTransfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__edma__driver.html#structedma__chn__state__t">edma_chn_state_t</a> *&#160;</td>
          <td class="paramname"><em>chn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__edma__hal.html#structedma__software__tcd__t">edma_software_tcd_t</a> *&#160;</td>
          <td class="paramname"><em>stcd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__edma__driver.html#ga7803399034b374663f76a589da7d8419">edma_transfer_type_t</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bytesOnEachRequest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__edma__driver.html#structedma__scatter__gather__list__t">edma_scatter_gather_list_t</a> *&#160;</td>
          <td class="paramname"><em>srcList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__edma__driver.html#structedma__scatter__gather__list__t">edma_scatter_gather_list_t</a> *&#160;</td>
          <td class="paramname"><em>destList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function configures the descriptors into a sing-end chain. The user passes blocks of memory into this function. The interrupt is triggered only when the last memory block is completed. The memory block information is passed with the <a class="el" href="group__edma__driver.html#structedma__scatter__gather__list__t" title="Data structure for configuring a discrete memory transfer. ">edma_scatter_gather_list_t</a> data structure, which can tell the memory address and length. The DMA driver configures the descriptor for each memory block, transfers the descriptor from the first one to the last one, and stops.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chn</td><td>The pointer to the channel state structure. </td></tr>
    <tr><td class="paramname">stcd</td><td>Memory pointing to software TCDs. The user must prepare this memory block. The required memory size is equal to the "number" * size of(edma_software_tcd_t). At the same time, the "stcd" must align with 32 bytes. If not, an error occurs in the eDMA driver. </td></tr>
    <tr><td class="paramname">type</td><td>Transfer type. </td></tr>
    <tr><td class="paramname">size</td><td>Size to be transferred on each DMA write/read. Source/Dest share the same write/read size. </td></tr>
    <tr><td class="paramname">bytesOnEachRequest</td><td>Size write/read for each trigger of the DMA request. </td></tr>
    <tr><td class="paramname">srcList</td><td>Data structure storing the address and length to be transferred for source memory blocks. If the source memory is peripheral, the length is not used. </td></tr>
    <tr><td class="paramname">destList</td><td>Data structure storing the address and length to be transferred for dest memory blocks. If in the memory-to-memory transfer mode, the user must ensure that the length of the dest scatter gather list is equal to the source scatter gather list. If the dest memory is a peripheral register, the length is not used. </td></tr>
    <tr><td class="paramname">number</td><td>A number of memory block contained in the scatter gather list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code of kStatus_EDMA_Success </dd></dl>

</div>
</div>
<a class="anchor" id="gae5dc17a0595a4e27b4877edea7549ece"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__edma__hal.html#gab6319bfbfaebd007f7871ae5be5eebe4">edma_status_t</a> EDMA_DRV_StartChannel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__edma__driver.html#structedma__chn__state__t">edma_chn_state_t</a> *&#160;</td>
          <td class="paramname"><em>chn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function enables the eDMA channel DMA request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chn</td><td>The pointer to the channel state structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An eDMA error codes or kStatus_EDMA_Success. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf0b33587b9f7ab6321c5e390564d0aa7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__edma__hal.html#gab6319bfbfaebd007f7871ae5be5eebe4">edma_status_t</a> EDMA_DRV_StopChannel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__edma__driver.html#structedma__chn__state__t">edma_chn_state_t</a> *&#160;</td>
          <td class="paramname"><em>chn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function disables the eDMA channel DMA request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chn</td><td>The pointer to the channel state structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An eDMA error codes or kStatus_EDMA_Success. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8bb06f10bb3021e9847cea985f787301"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__edma__hal.html#gab6319bfbfaebd007f7871ae5be5eebe4">edma_status_t</a> EDMA_DRV_InstallCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__edma__driver.html#structedma__chn__state__t">edma_chn_state_t</a> *&#160;</td>
          <td class="paramname"><em>chn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__edma__driver.html#gab79e6ce110f65567abad8afb7dd94309">edma_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>parameter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function register the callback function and the parameter into the eDMA channel state structure. The callback function is called when the channel is complete or a channel error occurs. The eDMA driver passes the channel status to this callback function to indicate whether it is caused by the channel complete event or the channel error event.</p>
<p>To un-register the callback function, the user can set the callback function to "NULL" and call this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chn</td><td>The pointer to the channel state structure. </td></tr>
    <tr><td class="paramname">callback</td><td>The pointer to the callback function. </td></tr>
    <tr><td class="paramname">parameter</td><td>The pointer to the callback function's parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An eDMA error codes or kStatus_EDMA_Success. </dd></dl>

</div>
</div>
<a class="anchor" id="ga64bd6fed67de6dfd3ac084643077b083"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EDMA_DRV_IRQHandler </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is provided as the default flow for eDMA channel interrupt. This function clears status, and calls the callback functions. The user can add this function into the hardware interrupt entry can implement a custom interrupt action function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Virtual channel number. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab93343849db92e0d475d731358c1b8c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EDMA_DRV_ErrorIRQHandler </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is provided as the default action for eDMA module error interrupt. This function clears status, stops the error on a eDMA channel , and calls the eDMA channel callback function if the error eDMA channel is already requested. The user can add this function into the eDMA error interrupt entry and implement a custom interrupt action function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>eDMA module indicator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac2e2a0e878dee3214d75aae65b4371f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__edma__driver.html#ga10b6a19b129232cb5dbbb2b320c9c224">edma_chn_status_t</a> EDMA_DRV_GetChannelStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__edma__driver.html#structedma__chn__state__t">edma_chn_state_t</a> *&#160;</td>
          <td class="paramname"><em>chn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chn</td><td>The pointer to the channel state structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Channel status. </dd></dl>

</div>
</div>
<a class="anchor" id="ga88c4c3f2acddd4cfb242fcfb6aba073d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t EDMA_DRV_GetFinishedBytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__edma__driver.html#structedma__chn__state__t">edma_chn_state_t</a> *&#160;</td>
          <td class="paramname"><em>chn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function checks the TCD (Task Control Descriptor) status for a specified eDMA channel and returns the left bytes not to be transferred to the user. This function can't be used for a multi-TCD scenario and can only be used for one TCD scenario.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chn</td><td>The pointer to the channel state structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bytes already transferred for current TCD. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.5-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul class="foot">
    <li class="footer">Fri Jul 25 2014 &copy; 2014 Freescale Semiconductor, Inc. All rights reserved. 
    </li>
  </ul>
</div>
</body>
</html>
