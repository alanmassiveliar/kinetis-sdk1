<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Kinetis SDK API Reference Manual: ADC Peripheral Driver</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="fs_logo.gif"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Kinetis SDK API Reference Manual
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">Freescale Semiconductor, Inc.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Introduction</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>API&#160;Usage</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__adc__driver.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ADC Peripheral Driver<div class="ingroups"><a class="el" href="group__adc.html">Analog-to-Digital Converter (ADC)</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>This section describes the programming interface of the ADC Peripheral driver.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structadc__hw__cmp__config__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__driver.html#structadc__hw__cmp__config__t">adc_hw_cmp_config_t</a></td></tr>
<tr class="memdesc:structadc__hw__cmp__config__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the structure to configure the ADC module hardware compare.  <a href="group__adc__driver.html#structadc__hw__cmp__config__t">More...</a><br/></td></tr>
<tr class="separator:structadc__hw__cmp__config__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structadc__chn__config__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__driver.html#structadc__chn__config__t">adc_chn_config_t</a></td></tr>
<tr class="memdesc:structadc__chn__config__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the structure to configure the ADC channel.  <a href="group__adc__driver.html#structadc__chn__config__t">More...</a><br/></td></tr>
<tr class="separator:structadc__chn__config__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structadc__user__config__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__driver.html#structadc__user__config__t">adc_user_config_t</a></td></tr>
<tr class="memdesc:structadc__user__config__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the structure to initialize the ADC module converter.  <a href="group__adc__driver.html#structadc__user__config__t">More...</a><br/></td></tr>
<tr class="separator:structadc__user__config__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structadc__state__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__driver.html#structadc__state__t">adc_state_t</a></td></tr>
<tr class="memdesc:structadc__state__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal driver state information.  <a href="group__adc__driver.html#structadc__state__t">More...</a><br/></td></tr>
<tr class="separator:structadc__state__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gad9fc8eabdc20225ce36cf6b96d2bb98f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad9fc8eabdc20225ce36cf6b96d2bb98f"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__driver.html#gad9fc8eabdc20225ce36cf6b96d2bb98f">adc_callback_t</a> )(void)</td></tr>
<tr class="memdesc:gad9fc8eabdc20225ce36cf6b96d2bb98f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the type of a user-defined callback function. <br/></td></tr>
<tr class="separator:gad9fc8eabdc20225ce36cf6b96d2bb98f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf8fb4b8cc8fededb3a212fec1455ec82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__adc__hal.html#ga2a6a6e8349f02b5b357746a44166280c">adc_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__driver.html#gaf8fb4b8cc8fededb3a212fec1455ec82">ADC_DRV_StructInitUserConfigForIntMode</a> (<a class="el" href="group__adc__driver.html#structadc__user__config__t">adc_user_config_t</a> *userConfigPtr)</td></tr>
<tr class="memdesc:gaf8fb4b8cc8fededb3a212fec1455ec82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the initial user configuration for the interrupt mode.  <a href="#gaf8fb4b8cc8fededb3a212fec1455ec82">More...</a><br/></td></tr>
<tr class="separator:gaf8fb4b8cc8fededb3a212fec1455ec82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb20295d52942dcee3cbbbe894b2ec79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__adc__hal.html#ga2a6a6e8349f02b5b357746a44166280c">adc_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__driver.html#gadb20295d52942dcee3cbbbe894b2ec79">ADC_DRV_StructInitUserConfigForBlockingMode</a> (<a class="el" href="group__adc__driver.html#structadc__user__config__t">adc_user_config_t</a> *userConfigPtr)</td></tr>
<tr class="memdesc:gadb20295d52942dcee3cbbbe894b2ec79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the initial user configuration for blocking mode.  <a href="#gadb20295d52942dcee3cbbbe894b2ec79">More...</a><br/></td></tr>
<tr class="separator:gadb20295d52942dcee3cbbbe894b2ec79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93b329893714c40250d2da3ad40b8650"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__adc__hal.html#ga2a6a6e8349f02b5b357746a44166280c">adc_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__driver.html#ga93b329893714c40250d2da3ad40b8650">ADC_DRV_StructInitUserConfigForOneTimeTriggerMode</a> (<a class="el" href="group__adc__driver.html#structadc__user__config__t">adc_user_config_t</a> *userConfigPtr)</td></tr>
<tr class="memdesc:ga93b329893714c40250d2da3ad40b8650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the initial user configuration for a one-time trigger mode.  <a href="#ga93b329893714c40250d2da3ad40b8650">More...</a><br/></td></tr>
<tr class="separator:ga93b329893714c40250d2da3ad40b8650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga788d9ee878cf74370c34d257f48085d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__adc__hal.html#ga2a6a6e8349f02b5b357746a44166280c">adc_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__driver.html#ga788d9ee878cf74370c34d257f48085d3">ADC_DRV_Init</a> (uint32_t instance, <a class="el" href="group__adc__driver.html#structadc__user__config__t">adc_user_config_t</a> *userConfigPtr, <a class="el" href="group__adc__driver.html#structadc__state__t">adc_state_t</a> *userStatePtr)</td></tr>
<tr class="memdesc:ga788d9ee878cf74370c34d257f48085d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the ADC module converter.  <a href="#ga788d9ee878cf74370c34d257f48085d3">More...</a><br/></td></tr>
<tr class="separator:ga788d9ee878cf74370c34d257f48085d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga202474dc45f4746384d4a8d811f3fe2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__driver.html#ga202474dc45f4746384d4a8d811f3fe2e">ADC_DRV_Deinit</a> (uint32_t instance)</td></tr>
<tr class="memdesc:ga202474dc45f4746384d4a8d811f3fe2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-initializes the ADC module converter.  <a href="#ga202474dc45f4746384d4a8d811f3fe2e">More...</a><br/></td></tr>
<tr class="separator:ga202474dc45f4746384d4a8d811f3fe2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4553cba797ad8d4d077a40f1b8a6c9d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__driver.html#ga4553cba797ad8d4d077a40f1b8a6c9d9">ADC_DRV_EnableLongSample</a> (uint32_t instance, <a class="el" href="group__adc__hal.html#gaa3b56b8dfdb7788f14016bd95ff2fae9">adc_long_sample_cycle_mode_t</a> mode)</td></tr>
<tr class="memdesc:ga4553cba797ad8d4d077a40f1b8a6c9d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the long sample mode feature.  <a href="#ga4553cba797ad8d4d077a40f1b8a6c9d9">More...</a><br/></td></tr>
<tr class="separator:ga4553cba797ad8d4d077a40f1b8a6c9d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a998938d9fe018c94570ce162b83466"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__driver.html#ga1a998938d9fe018c94570ce162b83466">ADC_DRV_DisableLongSample</a> (uint32_t instance)</td></tr>
<tr class="memdesc:ga1a998938d9fe018c94570ce162b83466"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the long sample mode feature.  <a href="#ga1a998938d9fe018c94570ce162b83466">More...</a><br/></td></tr>
<tr class="separator:ga1a998938d9fe018c94570ce162b83466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga385648be494342dceed5a929eefb160a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__adc__hal.html#ga2a6a6e8349f02b5b357746a44166280c">adc_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__driver.html#ga385648be494342dceed5a929eefb160a">ADC_DRV_EnableHwCmp</a> (uint32_t instance, <a class="el" href="group__adc__driver.html#structadc__hw__cmp__config__t">adc_hw_cmp_config_t</a> *hwCmpConfigPtr)</td></tr>
<tr class="memdesc:ga385648be494342dceed5a929eefb160a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the hardware compare feature.  <a href="#ga385648be494342dceed5a929eefb160a">More...</a><br/></td></tr>
<tr class="separator:ga385648be494342dceed5a929eefb160a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga276b1c15fa0bf3d6902a958ef279f818"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__driver.html#ga276b1c15fa0bf3d6902a958ef279f818">ADC_DRV_DisableHwCmp</a> (uint32_t instance)</td></tr>
<tr class="memdesc:ga276b1c15fa0bf3d6902a958ef279f818"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the hardware compare feature.  <a href="#ga276b1c15fa0bf3d6902a958ef279f818">More...</a><br/></td></tr>
<tr class="separator:ga276b1c15fa0bf3d6902a958ef279f818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8dfa4386c1f1e6918a698b8b675e6a17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__adc__hal.html#ga2a6a6e8349f02b5b357746a44166280c">adc_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__driver.html#ga8dfa4386c1f1e6918a698b8b675e6a17">ADC_DRV_ConfigConvChn</a> (uint32_t instance, uint32_t chnGroup, <a class="el" href="group__adc__driver.html#structadc__chn__config__t">adc_chn_config_t</a> *chnConfigPtr)</td></tr>
<tr class="memdesc:ga8dfa4386c1f1e6918a698b8b675e6a17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the conversion channel by software.  <a href="#ga8dfa4386c1f1e6918a698b8b675e6a17">More...</a><br/></td></tr>
<tr class="separator:ga8dfa4386c1f1e6918a698b8b675e6a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb28431568ed00120061e142e339cfb0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__driver.html#gadb28431568ed00120061e142e339cfb0">ADC_DRV_WaitConvDone</a> (uint32_t instance, uint32_t chnGroup)</td></tr>
<tr class="memdesc:gadb28431568ed00120061e142e339cfb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for the latest conversion to be complete.  <a href="#gadb28431568ed00120061e142e339cfb0">More...</a><br/></td></tr>
<tr class="separator:gadb28431568ed00120061e142e339cfb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b00fe679f18ff2afc794411bb5f8e14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__driver.html#ga5b00fe679f18ff2afc794411bb5f8e14">ADC_DRV_PauseConv</a> (uint32_t instance, uint32_t chnGroup)</td></tr>
<tr class="memdesc:ga5b00fe679f18ff2afc794411bb5f8e14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pauses the current conversion by software.  <a href="#ga5b00fe679f18ff2afc794411bb5f8e14">More...</a><br/></td></tr>
<tr class="separator:ga5b00fe679f18ff2afc794411bb5f8e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga238598fd25e9e443fcef9189c3822c04"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__driver.html#ga238598fd25e9e443fcef9189c3822c04">ADC_DRV_GetConvValueRAW</a> (uint32_t instance, uint32_t chnGroup)</td></tr>
<tr class="memdesc:ga238598fd25e9e443fcef9189c3822c04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the latest conversion value.  <a href="#ga238598fd25e9e443fcef9189c3822c04">More...</a><br/></td></tr>
<tr class="separator:ga238598fd25e9e443fcef9189c3822c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab8c2edb9264d6abd720089aefaf74cc"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__driver.html#gaab8c2edb9264d6abd720089aefaf74cc">ADC_DRV_GetConvValueRAWInt</a> (uint32_t instance, uint32_t chnGroup)</td></tr>
<tr class="memdesc:gaab8c2edb9264d6abd720089aefaf74cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the latest conversion value in the buffer when using the interrupt mode.  <a href="#gaab8c2edb9264d6abd720089aefaf74cc">More...</a><br/></td></tr>
<tr class="separator:gaab8c2edb9264d6abd720089aefaf74cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a97c135cfe7cbd67a69f54070c08ef9"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__driver.html#ga2a97c135cfe7cbd67a69f54070c08ef9">ADC_DRV_ConvRAWData</a> (uint16_t convValue, bool diffEnable, <a class="el" href="group__adc__hal.html#gaa8fa5f0c4bdbd09e46f7b0db4d194219">adc_resolution_mode_t</a> mode)</td></tr>
<tr class="memdesc:ga2a97c135cfe7cbd67a69f54070c08ef9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats the initial value fetched from the ADC module.  <a href="#ga2a97c135cfe7cbd67a69f54070c08ef9">More...</a><br/></td></tr>
<tr class="separator:ga2a97c135cfe7cbd67a69f54070c08ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga830b9eb246940081b2fe90f8701d71ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__adc__hal.html#ga2a6a6e8349f02b5b357746a44166280c">adc_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__driver.html#ga830b9eb246940081b2fe90f8701d71ed">ADC_DRV_InstallCallback</a> (uint32_t instance, uint32_t chnGroup, <a class="el" href="group__adc__driver.html#gad9fc8eabdc20225ce36cf6b96d2bb98f">adc_callback_t</a> userCallback)</td></tr>
<tr class="memdesc:ga830b9eb246940081b2fe90f8701d71ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Installs the user-defined callback in the ADC module.  <a href="#ga830b9eb246940081b2fe90f8701d71ed">More...</a><br/></td></tr>
<tr class="separator:ga830b9eb246940081b2fe90f8701d71ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e38a8d9f33d87698d19f571b60b9254"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__driver.html#ga0e38a8d9f33d87698d19f571b60b9254">ADC_DRV_IRQHandler</a> (uint32_t instance)</td></tr>
<tr class="memdesc:ga0e38a8d9f33d87698d19f571b60b9254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Driver-defined ISR in the ADC module.  <a href="#ga0e38a8d9f33d87698d19f571b60b9254">More...</a><br/></td></tr>
<tr class="separator:ga0e38a8d9f33d87698d19f571b60b9254"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>


<h3><a class="anchor" id="adcpd"></a>ADC Peripheral Driver</h3><div class="textblock"><h1>Overview</h1>
The ADC peripheral driver configures the ADC (Analog-to-Digital Converter). It handles calibration, initialization and configuration of ADC module.<h1>Driver model building</h1>
ADC driver has three parts:<ul>
<li>Basic Converter - This part handles the mechanism that converts the external analog voltage to digital value. The API functions configure the converter.</li>
<li>Channel Mux - Multiple channels share the converter in each ADC instance because of the time division multiplexing. However, the converter can only handle one channel at a time. To get the value of an indicated channel, the channel mux should be set to the connection between an indicated pad and the converter's input. The conversion value during this period is for the channel only. The API functions configure the channel.</li>
<li>Advance Feature Group - The advanced feature group covers optional features for applications. These features includes some that are already implemented by hardware, such as the calibration, hardware average, hardware compare, different power, and speed mode. The APIs for this part configure the advanced features. Although these features are optional, they are recommended to ensure that the ADC performs better, especially for calibration.</li>
</ul>
<h1>Initialization</h1>
Note that the calibration should be done before all the other operations.To initialize the ADC driver, a configuration structure is needed and should be filled with an available configuration. To make it easier to fill the structure, API functions have been designed for typical use cases. See the "Call diagram" section for typical use cases. Additionally, the application should provide a block of memory to keep the state while the driver operates. After the configuration structure is available and memory is allocated to keep state, the ADC module can be initialized by calling the API of <a class="el" href="group__adc__driver.html#ga788d9ee878cf74370c34d257f48085d3" title="Initializes the ADC module converter. ">ADC_DRV_Init()</a> function.<h1>Call diagram</h1>
Three kinds of typical use cases are designed for the ADC module:<ul>
<li>Interrupt mode - Interrupt mode works alone with continuous conversion. If it is chosen, the internal ADC ISR, inside the ADC PD driver, moves the conversion value from the result register to the internal buffer after the conversion is complete. As a result, the ADC data buffer is always updated continuously. The API function, which is reading the buffer, returns the latest conversion result to the application. Use the interrupt mode carefully with the continuous conversion, because too many interrupts might affect the main routine. You should use the low conversion speed in this mode.</li>
<li>Blocking mode. Blocking mode is working alone with continuous conversion mode too, but not enabling the interrupt. After trigger by configuring the channel, the conversion is launched. When conversion is completed, it would be blocked since the result data is still not read. It is so called blocking mode. Application should fetch the result data by API, and then the conversion could be continuous.</li>
<li>One-Time-Trigger Mode. One-Time-Trigger works without interrupt and continuous mode. Once triggered by configuring the channel, the conversion launches and the application fetches the result data. There is no auto operation to make the conversion continuous. The application should trigger the conversion again if another conversion is needed.</li>
</ul>
The three use cases are all based on the software trigger. However, they can easily be ported to use the hardware trigger. The only modification is to enable the hardware trigger when initializing the converter.The complex use cases, such as the DMA and the multiple channel scan need another module to work correctly. They can be customized according to the application.These are the examples to initialize and configure the ADC driver for typical use cases.Interrupt Mode:<div class="fragment"><div class="line"><span class="comment">/* adc_test_int.c */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;stdint.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdbool.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;fsl_adc_driver.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;fsl_os_abstraction.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">static</span> uint32_t MyIsrCounter = 0U;</div>
<div class="line"><span class="keywordtype">void</span> ADC_TEST_MyIsr(<span class="keywordtype">void</span>);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> ADC_TEST_IntMode(uint32_t instance, uint8_t chn, uint32_t times)</div>
<div class="line">{</div>
<div class="line"><span class="preprocessor">#if FSL_FEATURE_ADC_HAS_CALIBRATION</span></div>
<div class="line"><span class="preprocessor"></span>    adc_calibration_param_t MyAdcCalibraitionParam;</div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">/* FSL_FEATURE_ADC_HAS_CALIBRATION */</span><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor"></span>    <a class="code" href="group__adc__driver.html#structadc__user__config__t">adc_user_config_t</a> MyAdcUserConfig;</div>
<div class="line">    <a class="code" href="group__adc__driver.html#structadc__state__t">adc_state_t</a> MyAdcState;</div>
<div class="line">    <a class="code" href="group__adc__driver.html#structadc__chn__config__t">adc_chn_config_t</a> MyChnConfig;</div>
<div class="line">    <span class="keyword">volatile</span> int32_t MyAdcValue;</div>
<div class="line">    uint32_t LoopCounter = 0U;</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#if FSL_FEATURE_ADC_HAS_CALIBRATION</span></div>
<div class="line"><span class="preprocessor"></span>    <span class="comment">/* Auto calibration. */</span></div>
<div class="line">    ADC_DRV_GetAutoCalibrationParam(instance, &amp;MyAdcCalibraitionParam);</div>
<div class="line">    ADC_DRV_SetCalibrationParam(instance, &amp;MyAdcCalibraitionParam);</div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">/* FSL_FEATURE_ADC_HAS_CALIBRATION */</span><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line">    <span class="comment">/* Initialization for interrupt mode. */</span> </div>
<div class="line">    <a class="code" href="group__adc__driver.html#gaf8fb4b8cc8fededb3a212fec1455ec82">ADC_DRV_StructInitUserConfigForIntMode</a>(&amp;MyAdcUserConfig);</div>
<div class="line">    <a class="code" href="group__adc__driver.html#ga788d9ee878cf74370c34d257f48085d3">ADC_DRV_Init</a>(instance, &amp;MyAdcUserConfig, &amp;MyAdcState);</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Install Callback function into ISR. */</span></div>
<div class="line">    <a class="code" href="group__adc__driver.html#ga830b9eb246940081b2fe90f8701d71ed">ADC_DRV_InstallCallback</a>(instance, 0U, ADC_TEST_MyIsr);</div>
<div class="line">    <span class="comment">/* Trigger indicated channel. */</span></div>
<div class="line">    MyChnConfig.<a class="code" href="group__adc__driver.html#a8063d3c17f14a354925ad82b7d27aa3b">chnNum</a> = chn;</div>
<div class="line">    MyChnConfig.<a class="code" href="group__adc__driver.html#a216b21c175cea62fad8369efd6ff492c">diffEnable</a> = <span class="keyword">false</span>;</div>
<div class="line">    MyChnConfig.<a class="code" href="group__adc__driver.html#aa388b7eaf6b5eb34217514a66e8b5d77">intEnable</a> = <span class="keyword">true</span>;</div>
<div class="line">    MyChnConfig.chnMux = kAdcChnMuxOfDefault;</div>
<div class="line">    <a class="code" href="group__adc__driver.html#ga8dfa4386c1f1e6918a698b8b675e6a17">ADC_DRV_ConfigConvChn</a>(instance, 0U, &amp;MyChnConfig);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">while</span> (LoopCounter &lt; times)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">/* Fetch the conversion value and format it. */</span></div>
<div class="line">        MyAdcValue = <a class="code" href="group__adc__driver.html#gaab8c2edb9264d6abd720089aefaf74cc">ADC_DRV_GetConvValueRAWInt</a>(instance, 0U);</div>
<div class="line">        printf(<span class="stringliteral">&quot;ADC_DRV_GetConvValueRAWInt: %d\r\n&quot;</span>, MyAdcValue);</div>
<div class="line">        MyAdcValue = <a class="code" href="group__adc__driver.html#ga2a97c135cfe7cbd67a69f54070c08ef9">ADC_DRV_ConvRAWData</a>(MyAdcValue, <span class="keyword">false</span>, <a class="code" href="group__adc__hal.html#ggaa8fa5f0c4bdbd09e46f7b0db4d194219afb4fab22e3ecbee4c88c72cf0ac5c485">kAdcResolutionBitOfSingleEndAs12</a>);</div>
<div class="line">        printf(<span class="stringliteral">&quot;ADC_DRV_ConvRAWData: %d\r\n&quot;</span>, MyAdcValue);</div>
<div class="line">        <span class="comment">/* To do something. */</span>   </div>
<div class="line">        LoopCounter++;</div>
<div class="line">        <a class="code" href="group__os__abstraction.html#ga80ec77b248ae8f3d564727e0cb78eaee">OSA_TimeDelay</a>(200);</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">/* Pause the conversion after testing. */</span></div>
<div class="line">    <a class="code" href="group__adc__driver.html#ga5b00fe679f18ff2afc794411bb5f8e14">ADC_DRV_PauseConv</a>(instance, 0U);</div>
<div class="line">    <span class="comment">/* Disable the ADC. */</span></div>
<div class="line">    <a class="code" href="group__adc__driver.html#ga202474dc45f4746384d4a8d811f3fe2e">ADC_DRV_Deinit</a>(instance);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> ADC_TEST_MyIsr(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    MyIsrCounter++;</div>
<div class="line">}</div>
</div><!-- fragment -->Blocking Mode:<div class="fragment"><div class="line"><span class="comment">/* adc_test_blocking.c */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdint.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdbool.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;fsl_adc_driver.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;fsl_os_abstraction.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> ADC_TEST_Blocking(uint32_t instance, uint8_t chn, uint32_t times)</div>
<div class="line">{</div>
<div class="line"><span class="preprocessor">#if FSL_FEATURE_ADC_HAS_CALIBRATION</span></div>
<div class="line"><span class="preprocessor"></span>    adc_calibration_param_t MyAdcCalibraitionParam;</div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">/* FSL_FEATURE_ADC_HAS_CALIBRATION */</span><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor"></span>    <a class="code" href="group__adc__driver.html#structadc__user__config__t">adc_user_config_t</a> MyAdcUserConfig;</div>
<div class="line">    <a class="code" href="group__adc__driver.html#structadc__state__t">adc_state_t</a> MyAdcState;</div>
<div class="line">    <a class="code" href="group__adc__driver.html#structadc__chn__config__t">adc_chn_config_t</a> MyChnConfig;</div>
<div class="line">    <span class="keyword">volatile</span> int32_t MyAdcValue;</div>
<div class="line">    uint32_t LoopCounter = 0U;</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#if FSL_FEATURE_ADC_HAS_CALIBRATION</span></div>
<div class="line"><span class="preprocessor"></span>    <span class="comment">/* Auto calibraion. */</span></div>
<div class="line">    ADC_DRV_GetAutoCalibrationParam(instance, &amp;MyAdcCalibraitionParam);</div>
<div class="line">    ADC_DRV_SetCalibrationParam(instance, &amp;MyAdcCalibraitionParam);</div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">/* FSL_FEATURE_ADC_HAS_CALIBRATION */</span><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line">    <span class="comment">/* Initialization for interrrupt mode. */</span> </div>
<div class="line">    <a class="code" href="group__adc__driver.html#gadb20295d52942dcee3cbbbe894b2ec79">ADC_DRV_StructInitUserConfigForBlockingMode</a>(&amp;MyAdcUserConfig);</div>
<div class="line">    <a class="code" href="group__adc__driver.html#ga788d9ee878cf74370c34d257f48085d3">ADC_DRV_Init</a>(instance, &amp;MyAdcUserConfig, &amp;MyAdcState);</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Trigger the channel 0. */</span></div>
<div class="line">    MyChnConfig.<a class="code" href="group__adc__driver.html#a8063d3c17f14a354925ad82b7d27aa3b">chnNum</a> = chn;</div>
<div class="line">    MyChnConfig.<a class="code" href="group__adc__driver.html#a216b21c175cea62fad8369efd6ff492c">diffEnable</a>= <span class="keyword">false</span>;</div>
<div class="line">    MyChnConfig.<a class="code" href="group__adc__driver.html#aa388b7eaf6b5eb34217514a66e8b5d77">intEnable</a> = <span class="keyword">false</span>;</div>
<div class="line">    MyChnConfig.chnMux = kAdcChnMuxOfDefault;</div>
<div class="line">    <a class="code" href="group__adc__driver.html#ga8dfa4386c1f1e6918a698b8b675e6a17">ADC_DRV_ConfigConvChn</a>(instance, 0U, &amp;MyChnConfig);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">while</span> (LoopCounter &lt; times)</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="group__adc__driver.html#gadb28431568ed00120061e142e339cfb0">ADC_DRV_WaitConvDone</a>(instance, 0U);</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Fetch the conversion value and format it. */</span></div>
<div class="line">        MyAdcValue = <a class="code" href="group__adc__driver.html#ga238598fd25e9e443fcef9189c3822c04">ADC_DRV_GetConvValueRAW</a>(instance, 0U);</div>
<div class="line">        printf(<span class="stringliteral">&quot;ADC_DRV_GetConvValueRAW: %d\r\n&quot;</span>, MyAdcValue);</div>
<div class="line">        MyAdcValue = <a class="code" href="group__adc__driver.html#ga2a97c135cfe7cbd67a69f54070c08ef9">ADC_DRV_ConvRAWData</a>(MyAdcValue, <span class="keyword">false</span>, <a class="code" href="group__adc__hal.html#ggaa8fa5f0c4bdbd09e46f7b0db4d194219afb4fab22e3ecbee4c88c72cf0ac5c485">kAdcResolutionBitOfSingleEndAs12</a>);</div>
<div class="line">        printf(<span class="stringliteral">&quot;ADC_DRV_ConvRAWData: %d\r\n&quot;</span>, MyAdcValue);</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* To do something. */</span>   </div>
<div class="line">        LoopCounter++;</div>
<div class="line">        <a class="code" href="group__os__abstraction.html#ga80ec77b248ae8f3d564727e0cb78eaee">OSA_TimeDelay</a>(200);</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">/* Pause the conversion after testing. */</span></div>
<div class="line">    <a class="code" href="group__adc__driver.html#ga5b00fe679f18ff2afc794411bb5f8e14">ADC_DRV_PauseConv</a>(instance, 0U);</div>
<div class="line">    <span class="comment">/* Disable the ADC. */</span></div>
<div class="line">    <a class="code" href="group__adc__driver.html#ga202474dc45f4746384d4a8d811f3fe2e">ADC_DRV_Deinit</a>(instance);</div>
<div class="line">}</div>
</div><!-- fragment -->One-Time-Trigger Mode:<div class="fragment"><div class="line"><span class="comment">/* adc_test_one_time_trigger.c */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdint.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdbool.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;fsl_adc_driver.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;fsl_os_abstraction.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> ADC_TEST_OneTimeTrigger(uint32_t instance, uint8_t chn, uint32_t times)</div>
<div class="line">{</div>
<div class="line"><span class="preprocessor">#if FSL_FEATURE_ADC_HAS_CALIBRATION</span></div>
<div class="line"><span class="preprocessor"></span>    adc_calibration_param_t MyAdcCalibraitionParam;</div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">/* FSL_FEATURE_ADC_HAS_CALIBRATION */</span><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor"></span>    <a class="code" href="group__adc__driver.html#structadc__user__config__t">adc_user_config_t</a> MyAdcUserConfig;</div>
<div class="line">    <a class="code" href="group__adc__driver.html#structadc__state__t">adc_state_t</a> MyAdcState;</div>
<div class="line">    <a class="code" href="group__adc__driver.html#structadc__chn__config__t">adc_chn_config_t</a> MyChnConfig;</div>
<div class="line">    <span class="keyword">volatile</span> int32_t MyAdcValue;</div>
<div class="line">    uint32_t LoopCounter = 0U;</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#if FSL_FEATURE_ADC_HAS_CALIBRATION</span></div>
<div class="line"><span class="preprocessor"></span>    <span class="comment">/* Auto calibraion. */</span></div>
<div class="line">    ADC_DRV_GetAutoCalibrationParam(instance, &amp;MyAdcCalibraitionParam);</div>
<div class="line">    ADC_DRV_SetCalibrationParam(instance, &amp;MyAdcCalibraitionParam);</div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">/* FSL_FEATURE_ADC_HAS_CALIBRATION */</span><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line">    <span class="comment">/* Initialization for interrrupt mode. */</span> </div>
<div class="line">    <a class="code" href="group__adc__driver.html#ga93b329893714c40250d2da3ad40b8650">ADC_DRV_StructInitUserConfigForOneTimeTriggerMode</a>(&amp;MyAdcUserConfig);</div>
<div class="line">    <a class="code" href="group__adc__driver.html#ga788d9ee878cf74370c34d257f48085d3">ADC_DRV_Init</a>(instance, &amp;MyAdcUserConfig, &amp;MyAdcState);</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Setting for channel 0. */</span></div>
<div class="line">    MyChnConfig.<a class="code" href="group__adc__driver.html#a8063d3c17f14a354925ad82b7d27aa3b">chnNum</a> = chn;</div>
<div class="line">    MyChnConfig.<a class="code" href="group__adc__driver.html#a216b21c175cea62fad8369efd6ff492c">diffEnable</a>= <span class="keyword">false</span>;</div>
<div class="line">    MyChnConfig.<a class="code" href="group__adc__driver.html#aa388b7eaf6b5eb34217514a66e8b5d77">intEnable</a> = <span class="keyword">false</span>;</div>
<div class="line">    MyChnConfig.chnMux = kAdcChnMuxOfDefault;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">while</span> (LoopCounter &lt; times)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">/* Trigger the conversion with indicated channel&#39;s configuration. */</span></div>
<div class="line">        <a class="code" href="group__adc__driver.html#ga8dfa4386c1f1e6918a698b8b675e6a17">ADC_DRV_ConfigConvChn</a>(instance, 0U, &amp;MyChnConfig);</div>
<div class="line">        <span class="comment">/* Wait for the conversion to be done. */</span></div>
<div class="line">        <a class="code" href="group__adc__driver.html#gadb28431568ed00120061e142e339cfb0">ADC_DRV_WaitConvDone</a>(instance, 0U);</div>
<div class="line">        <span class="comment">/* Fetch the conversion value and format it. */</span></div>
<div class="line">        MyAdcValue = <a class="code" href="group__adc__driver.html#ga238598fd25e9e443fcef9189c3822c04">ADC_DRV_GetConvValueRAW</a>(instance, 0U);</div>
<div class="line">        printf(<span class="stringliteral">&quot;ADC_DRV_GetConvValueRAW: %d\r\n&quot;</span>, MyAdcValue);</div>
<div class="line">        MyAdcValue = <a class="code" href="group__adc__driver.html#ga2a97c135cfe7cbd67a69f54070c08ef9">ADC_DRV_ConvRAWData</a>(MyAdcValue, <span class="keyword">false</span>, <a class="code" href="group__adc__hal.html#ggaa8fa5f0c4bdbd09e46f7b0db4d194219afb4fab22e3ecbee4c88c72cf0ac5c485">kAdcResolutionBitOfSingleEndAs12</a>);</div>
<div class="line">        printf(<span class="stringliteral">&quot;ADC_DRV_ConvRAWData: %d\r\n&quot;</span>, MyAdcValue);</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* To do something. */</span> </div>
<div class="line">        LoopCounter++;</div>
<div class="line">        <a class="code" href="group__os__abstraction.html#ga80ec77b248ae8f3d564727e0cb78eaee">OSA_TimeDelay</a>(200);</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">/* Pause the conversion after testing. */</span></div>
<div class="line">    <a class="code" href="group__adc__driver.html#ga5b00fe679f18ff2afc794411bb5f8e14">ADC_DRV_PauseConv</a>(instance, 0U);</div>
<div class="line">    <span class="comment">/* Disable the ADC. */</span></div>
<div class="line">    <a class="code" href="group__adc__driver.html#ga202474dc45f4746384d4a8d811f3fe2e">ADC_DRV_Deinit</a>(instance);</div>
<div class="line">}</div>
</div><!-- fragment -->For Advanced Features:<div class="fragment"><div class="line"><span class="comment">/* adc_test_advanced_feature.c */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdint.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdbool.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;fsl_adc_driver.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;fsl_os_abstraction.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> ADC_TEST_AdvancedFeature(uint32_t instance, uint8_t chn, uint32_t times)</div>
<div class="line">{</div>
<div class="line"><span class="preprocessor">#if FSL_FEATURE_ADC_HAS_CALIBRATION</span></div>
<div class="line"><span class="preprocessor"></span>    adc_calibration_param_t MyAdcCalibraitionParam;</div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">/* FSL_FEATURE_ADC_HAS_CALIBRATION */</span><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor"></span>    <a class="code" href="group__adc__driver.html#structadc__user__config__t">adc_user_config_t</a> MyAdcUserConfig;</div>
<div class="line">    <a class="code" href="group__adc__driver.html#structadc__state__t">adc_state_t</a> MyAdcState;</div>
<div class="line">    <a class="code" href="group__adc__driver.html#structadc__chn__config__t">adc_chn_config_t</a> MyChnConfig;</div>
<div class="line">    <span class="keyword">volatile</span> int32_t MyAdcValue;</div>
<div class="line">    uint32_t LoopCounter = 0U;</div>
<div class="line">    <a class="code" href="group__adc__driver.html#structadc__hw__cmp__config__t">adc_hw_cmp_config_t</a> MyAdcHwCmpConfig;</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#if FSL_FEATURE_ADC_HAS_CALIBRATION</span></div>
<div class="line"><span class="preprocessor"></span>    <span class="comment">/* Auto calibraion. */</span></div>
<div class="line">    ADC_DRV_GetAutoCalibrationParam(instance, &amp;MyAdcCalibraitionParam);</div>
<div class="line">    ADC_DRV_SetCalibrationParam(instance, &amp;MyAdcCalibraitionParam);</div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">/* FSL_FEATURE_ADC_HAS_CALIBRATION */</span><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line">    <span class="comment">/* Initialization for interrrupt mode. */</span> </div>
<div class="line">    <a class="code" href="group__adc__driver.html#ga93b329893714c40250d2da3ad40b8650">ADC_DRV_StructInitUserConfigForOneTimeTriggerMode</a>(&amp;MyAdcUserConfig);</div>
<div class="line">    <a class="code" href="group__adc__driver.html#ga788d9ee878cf74370c34d257f48085d3">ADC_DRV_Init</a>(instance, &amp;MyAdcUserConfig, &amp;MyAdcState);</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Setting for advanced feature. */</span></div>
<div class="line">    <span class="comment">/* Hardware compare. */</span></div>
<div class="line">    MyAdcHwCmpConfig.cmpRangeMode = <a class="code" href="group__adc__hal.html#gga72f14ce03786fb9572885a197a377291a1697a1c863e81f044280490558b8d407">kAdcHwCmpRangeModeOf4</a>;</div>
<div class="line">        <span class="comment">/* Available range is between cmpValue1 and cmpValue2. */</span></div>
<div class="line">    MyAdcHwCmpConfig.<a class="code" href="group__adc__driver.html#a3d736a363e1604e33a3af5d2cf57e747">cmpValue1</a> = 0x0010U;</div>
<div class="line">    MyAdcHwCmpConfig.<a class="code" href="group__adc__driver.html#ae647871562099382c965e475abd322a2">cmpValue2</a> = 0xFFF0U;</div>
<div class="line">    <a class="code" href="group__adc__driver.html#ga385648be494342dceed5a929eefb160a">ADC_DRV_EnableHwCmp</a>(instance, &amp;MyAdcHwCmpConfig);</div>
<div class="line">    <span class="comment">/* Long sample mode. */</span></div>
<div class="line">    <a class="code" href="group__adc__driver.html#ga4553cba797ad8d4d077a40f1b8a6c9d9">ADC_DRV_EnableLongSample</a>(instance, <a class="code" href="group__adc__hal.html#ggaa3b56b8dfdb7788f14016bd95ff2fae9a84213ac958bf0e3ba239431c359d6491">kAdcLongSampleCycleOf16</a>);</div>
<div class="line">    <span class="comment">/* Hardware average. */</span></div>
<div class="line"><span class="preprocessor">#if FSL_FEATURE_ADC_HAS_HW_AVERAGE</span></div>
<div class="line"><span class="preprocessor"></span>    ADC_DRV_EnableHwAverage(instance, kAdcHwAverageCountOf32);</div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">/* FSL_FEATURE_ADC_HAS_HW_AVERAGE */</span><span class="preprocessor">  </span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line">    <span class="comment">/* Setting for channel. */</span></div>
<div class="line">    MyChnConfig.<a class="code" href="group__adc__driver.html#a8063d3c17f14a354925ad82b7d27aa3b">chnNum</a> = chn;</div>
<div class="line">    MyChnConfig.<a class="code" href="group__adc__driver.html#a216b21c175cea62fad8369efd6ff492c">diffEnable</a>= <span class="keyword">false</span>;</div>
<div class="line">    MyChnConfig.<a class="code" href="group__adc__driver.html#aa388b7eaf6b5eb34217514a66e8b5d77">intEnable</a> = <span class="keyword">false</span>;</div>
<div class="line">    MyChnConfig.chnMux = kAdcChnMuxOfDefault;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">while</span> (LoopCounter &lt; times)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">/* Trigger the conversion with indicated channel&#39;s configuration. */</span></div>
<div class="line">        <a class="code" href="group__adc__driver.html#ga8dfa4386c1f1e6918a698b8b675e6a17">ADC_DRV_ConfigConvChn</a>(instance, 0U, &amp;MyChnConfig);</div>
<div class="line">        <span class="comment">/* Wait for the conversion to be done. */</span></div>
<div class="line">        <a class="code" href="group__adc__driver.html#gadb28431568ed00120061e142e339cfb0">ADC_DRV_WaitConvDone</a>(instance, 0U);</div>
<div class="line">        <span class="comment">/* Fetch the conversion value and format it. */</span></div>
<div class="line">        MyAdcValue = <a class="code" href="group__adc__driver.html#ga238598fd25e9e443fcef9189c3822c04">ADC_DRV_GetConvValueRAW</a>(instance, 0U);</div>
<div class="line">        printf(<span class="stringliteral">&quot;ADC_DRV_GetConvValueRAW: %d\r\n&quot;</span>, MyAdcValue);</div>
<div class="line">        MyAdcValue = <a class="code" href="group__adc__driver.html#ga2a97c135cfe7cbd67a69f54070c08ef9">ADC_DRV_ConvRAWData</a>(MyAdcValue, <span class="keyword">false</span>, <a class="code" href="group__adc__hal.html#ggaa8fa5f0c4bdbd09e46f7b0db4d194219afb4fab22e3ecbee4c88c72cf0ac5c485">kAdcResolutionBitOfSingleEndAs12</a>);</div>
<div class="line">        printf(<span class="stringliteral">&quot;ADC_DRV_ConvRAWData: %d\r\n&quot;</span>, MyAdcValue);</div>
<div class="line">        <span class="comment">/* To do something. */</span> </div>
<div class="line">        LoopCounter++;</div>
<div class="line">        <a class="code" href="group__os__abstraction.html#ga80ec77b248ae8f3d564727e0cb78eaee">OSA_TimeDelay</a>(200);</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">/* Pause the conversion after testing. */</span></div>
<div class="line">    <a class="code" href="group__adc__driver.html#ga5b00fe679f18ff2afc794411bb5f8e14">ADC_DRV_PauseConv</a>(instance, 0U);</div>
<div class="line">    <span class="comment">/* Disable the ADC. */</span></div>
<div class="line">    <a class="code" href="group__adc__driver.html#ga202474dc45f4746384d4a8d811f3fe2e">ADC_DRV_Deinit</a>(instance);</div>
<div class="line">}</div>
</div><!-- fragment --> </div><hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structadc__hw__cmp__config__t" id="structadc__hw__cmp__config__t"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct adc_hw_cmp_config_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>This structure keeps the configuration for the ADC internal comparator. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:a3d736a363e1604e33a3af5d2cf57e747"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__driver.html#a3d736a363e1604e33a3af5d2cf57e747">cmpValue1</a></td></tr>
<tr class="memdesc:a3d736a363e1604e33a3af5d2cf57e747"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value for CMP value 1.  <a href="#a3d736a363e1604e33a3af5d2cf57e747">More...</a><br/></td></tr>
<tr class="separator:a3d736a363e1604e33a3af5d2cf57e747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae647871562099382c965e475abd322a2"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__driver.html#ae647871562099382c965e475abd322a2">cmpValue2</a></td></tr>
<tr class="memdesc:ae647871562099382c965e475abd322a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value for CMP value 2.  <a href="#ae647871562099382c965e475abd322a2">More...</a><br/></td></tr>
<tr class="separator:ae647871562099382c965e475abd322a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b4fd0c56575f0c26fbab3e20045c2a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b4fd0c56575f0c26fbab3e20045c2a9"></a>
<a class="el" href="group__adc__hal.html#ga72f14ce03786fb9572885a197a377291">adc_hw_cmp_range_mode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cmpRangeMode</b></td></tr>
<tr class="separator:a0b4fd0c56575f0c26fbab3e20045c2a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Field Documentation</h4>
<a class="anchor" id="a3d736a363e1604e33a3af5d2cf57e747"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t adc_hw_cmp_config_t::cmpValue1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae647871562099382c965e475abd322a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t adc_hw_cmp_config_t::cmpValue2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select the available range to pass the comparator. </p>

</div>
</div>

</div>
</div>
<a name="structadc__chn__config__t" id="structadc__chn__config__t"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct adc_chn_config_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>This structure keeps the ADC channel configuration. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:a8063d3c17f14a354925ad82b7d27aa3b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__driver.html#a8063d3c17f14a354925ad82b7d27aa3b">chnNum</a></td></tr>
<tr class="memdesc:a8063d3c17f14a354925ad82b7d27aa3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selection of input channel number.  <a href="#a8063d3c17f14a354925ad82b7d27aa3b">More...</a><br/></td></tr>
<tr class="separator:a8063d3c17f14a354925ad82b7d27aa3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa388b7eaf6b5eb34217514a66e8b5d77"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__driver.html#aa388b7eaf6b5eb34217514a66e8b5d77">intEnable</a></td></tr>
<tr class="memdesc:aa388b7eaf6b5eb34217514a66e8b5d77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable trigger interrupt when the conversion is complete.  <a href="#aa388b7eaf6b5eb34217514a66e8b5d77">More...</a><br/></td></tr>
<tr class="separator:aa388b7eaf6b5eb34217514a66e8b5d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a216b21c175cea62fad8369efd6ff492c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__driver.html#a216b21c175cea62fad8369efd6ff492c">diffEnable</a></td></tr>
<tr class="memdesc:a216b21c175cea62fad8369efd6ff492c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable setting the differential mode for conversion.  <a href="#a216b21c175cea62fad8369efd6ff492c">More...</a><br/></td></tr>
<tr class="separator:a216b21c175cea62fad8369efd6ff492c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Field Documentation</h4>
<a class="anchor" id="a8063d3c17f14a354925ad82b7d27aa3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t adc_chn_config_t::chnNum</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa388b7eaf6b5eb34217514a66e8b5d77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool adc_chn_config_t::intEnable</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a216b21c175cea62fad8369efd6ff492c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool adc_chn_config_t::diffEnable</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>

</div>
</div>
<a name="structadc__user__config__t" id="structadc__user__config__t"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct adc_user_config_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>This structure keeps the configuration for the ADC module converter. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:a173e28cc0db96fdccbc4ee6e806221d7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__driver.html#a173e28cc0db96fdccbc4ee6e806221d7">intEnable</a></td></tr>
<tr class="memdesc:a173e28cc0db96fdccbc4ee6e806221d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable internal ISR.  <a href="#a173e28cc0db96fdccbc4ee6e806221d7">More...</a><br/></td></tr>
<tr class="separator:a173e28cc0db96fdccbc4ee6e806221d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a320fb53628c8be72f1575f88da1b1a14"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__driver.html#a320fb53628c8be72f1575f88da1b1a14">lowPowerEnable</a></td></tr>
<tr class="memdesc:a320fb53628c8be72f1575f88da1b1a14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable low power mode for converter.  <a href="#a320fb53628c8be72f1575f88da1b1a14">More...</a><br/></td></tr>
<tr class="separator:a320fb53628c8be72f1575f88da1b1a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a511da7fe943ee5f409c7168010aed2c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__adc__hal.html#ga4f27e89da618b1b33b501ef094896aeb">adc_clk_divider_mode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__driver.html#a511da7fe943ee5f409c7168010aed2c5">clkDividerMode</a></td></tr>
<tr class="memdesc:a511da7fe943ee5f409c7168010aed2c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select divider of input clock for converter.  <a href="#a511da7fe943ee5f409c7168010aed2c5">More...</a><br/></td></tr>
<tr class="separator:a511da7fe943ee5f409c7168010aed2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c2c0cd9d46351aeb142cf904560ea1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__adc__hal.html#gaa8fa5f0c4bdbd09e46f7b0db4d194219">adc_resolution_mode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__driver.html#ab1c2c0cd9d46351aeb142cf904560ea1">resolutionMode</a></td></tr>
<tr class="memdesc:ab1c2c0cd9d46351aeb142cf904560ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select conversion resolution for converter.  <a href="#ab1c2c0cd9d46351aeb142cf904560ea1">More...</a><br/></td></tr>
<tr class="separator:ab1c2c0cd9d46351aeb142cf904560ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f16c22c344801d75ec57cde9752516"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__adc__hal.html#ga27fd370fd0bd34add47043f9e04e028f">adc_clk_src_mode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__driver.html#aa8f16c22c344801d75ec57cde9752516">clkSrcMode</a></td></tr>
<tr class="memdesc:aa8f16c22c344801d75ec57cde9752516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select source of input clock for converter.  <a href="#aa8f16c22c344801d75ec57cde9752516">More...</a><br/></td></tr>
<tr class="separator:aa8f16c22c344801d75ec57cde9752516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e523e38158f9df1aa102b5c4f6f286"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__driver.html#a07e523e38158f9df1aa102b5c4f6f286">asyncClkEnable</a></td></tr>
<tr class="memdesc:a07e523e38158f9df1aa102b5c4f6f286"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable asynchronous clock output at when initializing converter.  <a href="#a07e523e38158f9df1aa102b5c4f6f286">More...</a><br/></td></tr>
<tr class="separator:a07e523e38158f9df1aa102b5c4f6f286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af952184154573caa8ba57dc68da58aa8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__driver.html#af952184154573caa8ba57dc68da58aa8">highSpeedEnable</a></td></tr>
<tr class="memdesc:af952184154573caa8ba57dc68da58aa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the high speed mode for converter.  <a href="#af952184154573caa8ba57dc68da58aa8">More...</a><br/></td></tr>
<tr class="separator:af952184154573caa8ba57dc68da58aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dcaed7ff27fdcc56d168bd181df846c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__driver.html#a5dcaed7ff27fdcc56d168bd181df846c">hwTriggerEnable</a></td></tr>
<tr class="memdesc:a5dcaed7ff27fdcc56d168bd181df846c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable triggering by hardware.  <a href="#a5dcaed7ff27fdcc56d168bd181df846c">More...</a><br/></td></tr>
<tr class="separator:a5dcaed7ff27fdcc56d168bd181df846c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4513c047b2dceb999b0b3e47338b0b68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__adc__hal.html#gaf952ff3ec68e74e71a4d5252ab97d97d">adc_ref_volt_src_mode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__driver.html#a4513c047b2dceb999b0b3e47338b0b68">refVoltSrcMode</a></td></tr>
<tr class="memdesc:a4513c047b2dceb999b0b3e47338b0b68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select the reference voltage source for converter.  <a href="#a4513c047b2dceb999b0b3e47338b0b68">More...</a><br/></td></tr>
<tr class="separator:a4513c047b2dceb999b0b3e47338b0b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6daf84cfc092d2661a42b8b9ba166a2d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__driver.html#a6daf84cfc092d2661a42b8b9ba166a2d">continuousConvEnable</a></td></tr>
<tr class="memdesc:a6daf84cfc092d2661a42b8b9ba166a2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable launching the continuous conversion mode.  <a href="#a6daf84cfc092d2661a42b8b9ba166a2d">More...</a><br/></td></tr>
<tr class="separator:a6daf84cfc092d2661a42b8b9ba166a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Field Documentation</h4>
<a class="anchor" id="a173e28cc0db96fdccbc4ee6e806221d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool adc_user_config_t::intEnable</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a320fb53628c8be72f1575f88da1b1a14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool adc_user_config_t::lowPowerEnable</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a511da7fe943ee5f409c7168010aed2c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__adc__hal.html#ga4f27e89da618b1b33b501ef094896aeb">adc_clk_divider_mode_t</a> adc_user_config_t::clkDividerMode</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab1c2c0cd9d46351aeb142cf904560ea1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__adc__hal.html#gaa8fa5f0c4bdbd09e46f7b0db4d194219">adc_resolution_mode_t</a> adc_user_config_t::resolutionMode</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa8f16c22c344801d75ec57cde9752516"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__adc__hal.html#ga27fd370fd0bd34add47043f9e04e028f">adc_clk_src_mode_t</a> adc_user_config_t::clkSrcMode</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a07e523e38158f9df1aa102b5c4f6f286"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool adc_user_config_t::asyncClkEnable</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af952184154573caa8ba57dc68da58aa8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool adc_user_config_t::highSpeedEnable</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5dcaed7ff27fdcc56d168bd181df846c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool adc_user_config_t::hwTriggerEnable</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4513c047b2dceb999b0b3e47338b0b68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__adc__hal.html#gaf952ff3ec68e74e71a4d5252ab97d97d">adc_ref_volt_src_mode_t</a> adc_user_config_t::refVoltSrcMode</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6daf84cfc092d2661a42b8b9ba166a2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool adc_user_config_t::continuousConvEnable</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>

</div>
</div>
<a name="structadc__state__t" id="structadc__state__t"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct adc_state_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>The contents of this structure are internal to the driver and should not be modified by users. Also, contents of the structure are subject to change in future releases. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:a389205e462c90a3bb04c5f9046d37a4e"><td class="memItemLeft" ><a class="anchor" id="a389205e462c90a3bb04c5f9046d37a4e"></a>
struct {</td></tr>
<tr class="memitem:ac8333379b92106163af11edd6cc7266d"><td class="memItemLeft" >&#160;&#160;&#160;<a class="el" href="group__adc__driver.html#gad9fc8eabdc20225ce36cf6b96d2bb98f">adc_callback_t</a>&#160;&#160;&#160;<a class="el" href="group__adc__driver.html#a5523fb34393cf5a63171d8db5ef28fcd">userCallbackFunc</a></td></tr>
<tr class="memdesc:ac8333379b92106163af11edd6cc7266d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function that would be executed in ISR.  <a href="#ac8333379b92106163af11edd6cc7266d">More...</a><br/></td></tr>
<tr class="separator:ac8333379b92106163af11edd6cc7266d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c1e0ae79d57fe76963fafd938b9cfb"><td class="memItemLeft" >&#160;&#160;&#160;uint16_t&#160;&#160;&#160;<a class="el" href="group__adc__driver.html#a602ad2febd14fee5f17323b9438575fb">convBuff</a></td></tr>
<tr class="memdesc:a29c1e0ae79d57fe76963fafd938b9cfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data buffer when interrupt mode is used.  <a href="#a29c1e0ae79d57fe76963fafd938b9cfb">More...</a><br/></td></tr>
<tr class="separator:a29c1e0ae79d57fe76963fafd938b9cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a389205e462c90a3bb04c5f9046d37a4e"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><b>configGroup</b> [FSL_FEATURE_ADC_CONVERSION_CONTROL_COUNT]</td></tr>
<tr class="separator:a389205e462c90a3bb04c5f9046d37a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Field Documentation</h4>
<a class="anchor" id="a5523fb34393cf5a63171d8db5ef28fcd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__adc__driver.html#gad9fc8eabdc20225ce36cf6b96d2bb98f">adc_callback_t</a> adc_state_t::userCallbackFunc</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a602ad2febd14fee5f17323b9438575fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t adc_state_t::convBuff</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaf8fb4b8cc8fededb3a212fec1455ec82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__adc__hal.html#ga2a6a6e8349f02b5b357746a44166280c">adc_status_t</a> ADC_DRV_StructInitUserConfigForIntMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__adc__driver.html#structadc__user__config__t">adc_user_config_t</a> *&#160;</td>
          <td class="paramname"><em>userConfigPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function fills the initial user configuration for interrupt mode. Calling the initialization function with the filled parameter configures the ADC module to function in the interrupt mode. The settings are:</p>
<p>.intEnable = true; .lowPowerEnable = true; .clkDividerMode = kAdcClkDividerInputOf8; .resolutionMode = kAdcResolutionBitOf12or13; .clkSrcMode = kAdcClkSrcOfAsynClk; .asyncClkEnable = true; .highSpeedEnable = false; .hwTriggerEnable = false; .dmaEnable = false; .refVoltSrcMode = kAdcRefVoltSrcOfVref; .continuousConvEnable = true;</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">userConfigPtr</td><td>Pointer to the user configuration structure. See the "adc_user_config_t". </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Execution status. </dd></dl>

</div>
</div>
<a class="anchor" id="gadb20295d52942dcee3cbbbe894b2ec79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__adc__hal.html#ga2a6a6e8349f02b5b357746a44166280c">adc_status_t</a> ADC_DRV_StructInitUserConfigForBlockingMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__adc__driver.html#structadc__user__config__t">adc_user_config_t</a> *&#160;</td>
          <td class="paramname"><em>userConfigPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function fills the initial user configuration for blocking mode. Calling the initialization function with the filled parameter configures the ADC module to function in the blocking mode. The settings are:</p>
<p>.intEnable = false; .lowPowerEnable = false; .clkDividerMode = kAdcClkDividerInputOf8; .resolutionMode = kAdcResolutionBitOf12or13; .clkSrcMode = kAdcClkSrcOfBusClk; .asyncClkEnable = false; .highSpeedEnable = false; .hwTriggerEnable = false; .dmaEnable = false; .refVoltSrcMode = kAdcRefVoltSrcOfVref; .continuousConvEnable = true;</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">userConfigPtr</td><td>Pointer to the user configuration structure. See the "adc_user_config_t". </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Execution status. </dd></dl>

</div>
</div>
<a class="anchor" id="ga93b329893714c40250d2da3ad40b8650"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__adc__hal.html#ga2a6a6e8349f02b5b357746a44166280c">adc_status_t</a> ADC_DRV_StructInitUserConfigForOneTimeTriggerMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__adc__driver.html#structadc__user__config__t">adc_user_config_t</a> *&#160;</td>
          <td class="paramname"><em>userConfigPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function fills the initial user configuration for a one-time trigger mode. Calling the initialization function with the filled parameter configures the ADC module to function in the one-time trigger mode. The settings are:</p>
<p>.intEnable = false; .lowPowerEnable = false; .clkDividerMode = kAdcClkDividerInputOf8; .resolutionMode = kAdcResolutionBitOf12or13; .clkSrcMode = kAdcClkSrcOfBusClk; .asyncClkEnable = false; .highSpeedEnable = false; .hwTriggerEnable = false; .dmaEnable = false; .refVoltSrcMode = kAdcRefVoltSrcOfVref; .continuousConvEnable = false;</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">userConfigPtr</td><td>Pointer to the user configuration structure. See the "adc_user_config_t". </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Execution status. </dd></dl>

</div>
</div>
<a class="anchor" id="ga788d9ee878cf74370c34d257f48085d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__adc__hal.html#ga2a6a6e8349f02b5b357746a44166280c">adc_status_t</a> ADC_DRV_Init </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__adc__driver.html#structadc__user__config__t">adc_user_config_t</a> *&#160;</td>
          <td class="paramname"><em>userConfigPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__adc__driver.html#structadc__state__t">adc_state_t</a> *&#160;</td>
          <td class="paramname"><em>userStatePtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function initializes the converter in the ADC module. Regardless of the completed calibration for the device, this API function, with initial configuration should be called before any other operations. Initial configurations are mainly for the converter itself. For advanced features, the corresponding APIs should be called after this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ADC instance ID. </td></tr>
    <tr><td class="paramname">userConfigPtr</td><td>Pointer to the initialization structure. See the "adc_user_config_t". </td></tr>
    <tr><td class="paramname">userStatePtr</td><td>Pointer to the context memory structure. See the "adc_state_t". </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Execution status. </dd></dl>

</div>
</div>
<a class="anchor" id="ga202474dc45f4746384d4a8d811f3fe2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ADC_DRV_Deinit </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function de-initializes the ADC module. It gates the ADC module. When ADC is no longer used in application, calling this API function shuts down the device to reduce the power consumption.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ADC instance ID. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4553cba797ad8d4d077a40f1b8a6c9d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ADC_DRV_EnableLongSample </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__adc__hal.html#gaa3b56b8dfdb7788f14016bd95ff2fae9">adc_long_sample_cycle_mode_t</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function enables the long sample mode feature and sets it with the indicated configuration. Launching the long sample mode adjusts the sample period to allow the higher impedance inputs to be accurately sampled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ADC instance ID. </td></tr>
    <tr><td class="paramname">mode</td><td>Selection of configuration, see to "adc_long_sample_cycle_mode_t". </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1a998938d9fe018c94570ce162b83466"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ADC_DRV_DisableLongSample </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API function disables the long sample mode feature and</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ADC instance ID. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga385648be494342dceed5a929eefb160a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__adc__hal.html#ga2a6a6e8349f02b5b357746a44166280c">adc_status_t</a> ADC_DRV_EnableHwCmp </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__adc__driver.html#structadc__hw__cmp__config__t">adc_hw_cmp_config_t</a> *&#160;</td>
          <td class="paramname"><em>hwCmpConfigPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API enables the hardware compare feature with the indicated configuration. Launching the hardware compare ensures that the conversion, which results in a predefined range, can be only accepted. Values out of range are ignored during conversion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ADC instance ID. </td></tr>
    <tr><td class="paramname">hwCmpConfigPtr</td><td>Pointer to a configuration structure. See the "adc_hw_cmp_config_t". </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Execution status. </dd></dl>

</div>
</div>
<a class="anchor" id="ga276b1c15fa0bf3d6902a958ef279f818"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ADC_DRV_DisableHwCmp </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API function disables the hardware compare feature.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ADC instance ID. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8dfa4386c1f1e6918a698b8b675e6a17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__adc__hal.html#ga2a6a6e8349f02b5b357746a44166280c">adc_status_t</a> ADC_DRV_ConfigConvChn </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>chnGroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__adc__driver.html#structadc__chn__config__t">adc_chn_config_t</a> *&#160;</td>
          <td class="paramname"><em>chnConfigPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function configures the conversion channel. When the ADC module has been initialized by enabling the software trigger (disable hardware trigger), calling this API triggers the conversion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ADC instance ID. </td></tr>
    <tr><td class="paramname">chnGroup</td><td>Selection of the configuration group. </td></tr>
    <tr><td class="paramname">chnConfigPtr</td><td>Pointer to the configuration structure. See the "adc_chn_config_t". </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Execution status. </dd></dl>

</div>
</div>
<a class="anchor" id="gadb28431568ed00120061e142e339cfb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ADC_DRV_WaitConvDone </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>chnGroup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function waits for the latest conversion to be complete. When triggering the conversion by configuring the available channel, the converter is launched. This API function should be called to wait for the conversion to be complete when no interrupt or DMA mode is used for the ADC module. After the waiting period, the available data from the conversion result are fetched. The complete flag is not cleared until the result data is read.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ADC instance ID. </td></tr>
    <tr><td class="paramname">chnGroup</td><td>Selection of configuration group. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Execution status. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5b00fe679f18ff2afc794411bb5f8e14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ADC_DRV_PauseConv </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>chnGroup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function pauses the current conversion setting by software.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ADC instance ID. </td></tr>
    <tr><td class="paramname">chnGroup</td><td>Selection of configuration group. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga238598fd25e9e443fcef9189c3822c04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ADC_DRV_GetConvValueRAW </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>chnGroup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function gets the conversion value from the ADC module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ADC instance ID. </td></tr>
    <tr><td class="paramname">chnGroup</td><td>Selection of configuration group. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unformatted conversion value. </dd></dl>

</div>
</div>
<a class="anchor" id="gaab8c2edb9264d6abd720089aefaf74cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ADC_DRV_GetConvValueRAWInt </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>chnGroup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function gets the latest conversion value in the buffer when using the interrupt mode. Note that this function is only available in the interrupt mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ADC instance ID. </td></tr>
    <tr><td class="paramname">chnGroup</td><td>Selection of configuration group. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unformatted conversion value. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2a97c135cfe7cbd67a69f54070c08ef9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ADC_DRV_ConvRAWData </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>convValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>diffEnable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__adc__hal.html#gaa8fa5f0c4bdbd09e46f7b0db4d194219">adc_resolution_mode_t</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function formats the initial value fetched from the ADC module. Initial value fetched from the ADC module can't be read as a number, especially for the signed value generated by the differential conversion. This function can format the initial value to be a readable one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">convValue</td><td>Initial value directly from the register. </td></tr>
    <tr><td class="paramname">diffEnable</td><td>Identifier for the differential mode. </td></tr>
    <tr><td class="paramname">mode</td><td>Formatted data resolution mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Formatted conversion value. </dd></dl>

</div>
</div>
<a class="anchor" id="ga830b9eb246940081b2fe90f8701d71ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__adc__hal.html#ga2a6a6e8349f02b5b357746a44166280c">adc_status_t</a> ADC_DRV_InstallCallback </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>chnGroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__adc__driver.html#gad9fc8eabdc20225ce36cf6b96d2bb98f">adc_callback_t</a>&#160;</td>
          <td class="paramname"><em>userCallback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function installs the user-defined callback in the ADC module. When an ADC interrupt request is served, the callback is executed inside the ISR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ADC instance ID. </td></tr>
    <tr><td class="paramname">chnGroup</td><td>Selection of the configuration group. </td></tr>
    <tr><td class="paramname">userCallback</td><td>User-defined callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Execution status. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0e38a8d9f33d87698d19f571b60b9254"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ADC_DRV_IRQHandler </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is the driver-defined ISR in the ADC module. It includes the interrupt mode processes defined by the driver. Currently, it is called inside the system-defined ISR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ADC instance ID. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.5-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul class="foot">
    <li class="footer">Fri Jul 25 2014 &copy; 2014 Freescale Semiconductor, Inc. All rights reserved. 
    </li>
  </ul>
</div>
</body>
</html>
