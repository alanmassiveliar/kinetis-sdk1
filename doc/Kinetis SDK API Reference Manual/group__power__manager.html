<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Kinetis SDK API Reference Manual: Power Manager (Power)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="fs_logo.gif"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Kinetis SDK API Reference Manual
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">Freescale Semiconductor, Inc.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Introduction</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>API&#160;Usage</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__power__manager.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Power Manager (Power)</div>  </div>
</div><!--header-->
<div class="contents">

<p>The Kinetis SDK Power Manager provides a set of API/services to configure the power-related IPs, such as SMC, PMC, RCM, etc.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structpower__manager__user__config__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__power__manager.html#structpower__manager__user__config__t">power_manager_user_config_t</a></td></tr>
<tr class="memdesc:structpower__manager__user__config__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Power mode user configuration structure.  <a href="group__power__manager.html#structpower__manager__user__config__t">More...</a><br/></td></tr>
<tr class="separator:structpower__manager__user__config__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structpower__manager__static__callback__user__config__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__power__manager.html#structpower__manager__static__callback__user__config__t">power_manager_static_callback_user_config_t</a></td></tr>
<tr class="memdesc:structpower__manager__static__callback__user__config__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statically allocated callback.  <a href="group__power__manager.html#structpower__manager__static__callback__user__config__t">More...</a><br/></td></tr>
<tr class="separator:structpower__manager__static__callback__user__config__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structpower__manager__dynamic__callback__user__config__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__power__manager.html#structpower__manager__dynamic__callback__user__config__t">power_manager_dynamic_callback_user_config_t</a></td></tr>
<tr class="memdesc:structpower__manager__dynamic__callback__user__config__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamically allocated callback.  <a href="group__power__manager.html#structpower__manager__dynamic__callback__user__config__t">More...</a><br/></td></tr>
<tr class="separator:structpower__manager__dynamic__callback__user__config__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structpower__manager__state__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__power__manager.html#structpower__manager__state__t">power_manager_state_t</a></td></tr>
<tr class="memdesc:structpower__manager__state__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Power manager internal state structure.  <a href="group__power__manager.html#structpower__manager__state__t">More...</a><br/></td></tr>
<tr class="separator:structpower__manager__state__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga9ae951cf37a5ce9ba97d883434c298b4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__power__manager.html#ga9ae951cf37a5ce9ba97d883434c298b4">POWER_SYS_CALLBACK_BEFORE</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga9ae951cf37a5ce9ba97d883434c298b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal constant.  <a href="#ga9ae951cf37a5ce9ba97d883434c298b4">More...</a><br/></td></tr>
<tr class="separator:ga9ae951cf37a5ce9ba97d883434c298b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33c3bbae401fac6f7cbcf2f9bfd44849"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__power__manager.html#ga33c3bbae401fac6f7cbcf2f9bfd44849">POWER_SYS_CALLBACK_AFTER</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:ga33c3bbae401fac6f7cbcf2f9bfd44849"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal constant.  <a href="#ga33c3bbae401fac6f7cbcf2f9bfd44849">More...</a><br/></td></tr>
<tr class="separator:ga33c3bbae401fac6f7cbcf2f9bfd44849"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaf3b9a189d84fd798b7e293e070389753"><td class="memItemLeft" align="right" valign="top">typedef uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__power__manager.html#gaf3b9a189d84fd798b7e293e070389753">power_manager_callback_priority_t</a></td></tr>
<tr class="memdesc:gaf3b9a189d84fd798b7e293e070389753"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback invocation priority.  <a href="#gaf3b9a189d84fd798b7e293e070389753">More...</a><br/></td></tr>
<tr class="separator:gaf3b9a189d84fd798b7e293e070389753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0c24dfbcfffe38404e9974f56369355"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__power__manager.html#gaf0c24dfbcfffe38404e9974f56369355">power_manager_callback_handle_t</a></td></tr>
<tr class="memdesc:gaf0c24dfbcfffe38404e9974f56369355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback handle.  <a href="#gaf0c24dfbcfffe38404e9974f56369355">More...</a><br/></td></tr>
<tr class="separator:gaf0c24dfbcfffe38404e9974f56369355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf425e2ead1248e49133d9cb0b733f5e5"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__power__manager.html#gaf425e2ead1248e49133d9cb0b733f5e5">power_manager_callback_data_t</a></td></tr>
<tr class="memdesc:gaf425e2ead1248e49133d9cb0b733f5e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback-specific data.  <a href="#gaf425e2ead1248e49133d9cb0b733f5e5">More...</a><br/></td></tr>
<tr class="separator:gaf425e2ead1248e49133d9cb0b733f5e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a17cc3e84a51eeed42fb0a5365b12e3"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="group__power__manager.html#ga935122cf5948742441f087ac3f1588a2">power_manager_error_code_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__power__manager.html#ga4a17cc3e84a51eeed42fb0a5365b12e3">power_manager_callback_t</a> )(<a class="el" href="group__power__manager.html#ga63bea534f09850d600e1bce7f76dcd1b">power_manager_callback_type_t</a> type, <a class="el" href="group__power__manager.html#structpower__manager__user__config__t">power_manager_user_config_t</a> *configPtr, <a class="el" href="group__power__manager.html#gaf425e2ead1248e49133d9cb0b733f5e5">power_manager_callback_data_t</a> *dataPtr)</td></tr>
<tr class="memdesc:ga4a17cc3e84a51eeed42fb0a5365b12e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback prototype.  <a href="#ga4a17cc3e84a51eeed42fb0a5365b12e3">More...</a><br/></td></tr>
<tr class="separator:ga4a17cc3e84a51eeed42fb0a5365b12e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga307c693b6f883df898b9210262755d40"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__power__manager.html#ga307c693b6f883df898b9210262755d40">power_manager_modes_t</a> { <br/>
&#160;&#160;<b>kPowerManagerRun</b>, 
<br/>
&#160;&#160;<b>kPowerManagerVlpr</b>, 
<br/>
&#160;&#160;<b>kPowerManagerWait</b>, 
<br/>
&#160;&#160;<b>kPowerManagerVlpw</b>, 
<br/>
&#160;&#160;<b>kPowerManagerStop</b>, 
<br/>
&#160;&#160;<b>kPowerManagerVlps</b>, 
<br/>
&#160;&#160;<b>kPowerManagerLls</b>, 
<br/>
&#160;&#160;<b>kPowerManagerVlls0</b>, 
<br/>
&#160;&#160;<b>kPowerManagerVlls1</b>, 
<br/>
&#160;&#160;<b>kPowerManagerVlls2</b>, 
<br/>
&#160;&#160;<b>kPowerManagerVlls3</b>, 
<br/>
&#160;&#160;<b>kPowerManagerMax</b>
<br/>
 }</td></tr>
<tr class="memdesc:ga307c693b6f883df898b9210262755d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Power modes enumeration.  <a href="group__power__manager.html#ga307c693b6f883df898b9210262755d40">More...</a><br/></td></tr>
<tr class="separator:ga307c693b6f883df898b9210262755d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga935122cf5948742441f087ac3f1588a2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__power__manager.html#ga935122cf5948742441f087ac3f1588a2">power_manager_error_code_t</a> { <br/>
&#160;&#160;<b>kPowerManagerSuccess</b>, 
<br/>
&#160;&#160;<b>kPowerManagerError</b>, 
<br/>
&#160;&#160;<b>kPowerManagerErrorNotAvailable</b>, 
<br/>
&#160;&#160;<b>kPowerManagerErrorOutOfRange</b>, 
<br/>
&#160;&#160;<b>kPowerManagerErrorSwitch</b>, 
<br/>
&#160;&#160;<b>kPowerManagerErrorNotificationBefore</b>, 
<br/>
&#160;&#160;<b>kPowerManagerErrorNotificationAfter</b>
<br/>
 }</td></tr>
<tr class="memdesc:ga935122cf5948742441f087ac3f1588a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Power manager success code and error codes.  <a href="group__power__manager.html#ga935122cf5948742441f087ac3f1588a2">More...</a><br/></td></tr>
<tr class="separator:ga935122cf5948742441f087ac3f1588a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga557e8588368b90f97ba0a6fff173a447"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__power__manager.html#ga557e8588368b90f97ba0a6fff173a447">power_manager_policy_t</a> { <br/>
&#160;&#160;<b>kPowerManagerPolicyAgreement</b>, 
<br/>
&#160;&#160;<b>kPowerManagerPolicyForcible</b>
<br/>
 }</td></tr>
<tr class="memdesc:ga557e8588368b90f97ba0a6fff173a447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Power manager policies.  <a href="group__power__manager.html#ga557e8588368b90f97ba0a6fff173a447">More...</a><br/></td></tr>
<tr class="separator:ga557e8588368b90f97ba0a6fff173a447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63bea534f09850d600e1bce7f76dcd1b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__power__manager.html#ga63bea534f09850d600e1bce7f76dcd1b">power_manager_callback_type_t</a> { <br/>
&#160;&#160;<b>kPowerManagerCallbackNone</b>, 
<br/>
&#160;&#160;<b>kPowerManagerCallbackBefore</b>, 
<br/>
&#160;&#160;<b>kPowerManagerCallbackAfter</b>, 
<br/>
&#160;&#160;<b>kPowerManagerCallbackBeforeAfter</b>, 
<br/>
&#160;&#160;<b>kPowerManagerCallbackFailed</b>
<br/>
 }</td></tr>
<tr class="memdesc:ga63bea534f09850d600e1bce7f76dcd1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback invocation types.  <a href="group__power__manager.html#ga63bea534f09850d600e1bce7f76dcd1b">More...</a><br/></td></tr>
<tr class="separator:ga63bea534f09850d600e1bce7f76dcd1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga558a5f12d76ff23810fc637642f21d59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__power__manager.html#ga935122cf5948742441f087ac3f1588a2">power_manager_error_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__power__manager.html#ga558a5f12d76ff23810fc637642f21d59">POWER_SYS_Init</a> (<a class="el" href="group__power__manager.html#structpower__manager__user__config__t">power_manager_user_config_t</a> *(*powerConfigsPtr)[], uint8_t configsNumber, <a class="el" href="group__power__manager.html#structpower__manager__static__callback__user__config__t">power_manager_static_callback_user_config_t</a> *(*callbacksPtr)[], uint8_t callbacksNumber)</td></tr>
<tr class="memdesc:ga558a5f12d76ff23810fc637642f21d59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Power manager initialization for operation.  <a href="#ga558a5f12d76ff23810fc637642f21d59">More...</a><br/></td></tr>
<tr class="separator:ga558a5f12d76ff23810fc637642f21d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bfcc33858329e2b39a2c5c792db7cbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__power__manager.html#ga935122cf5948742441f087ac3f1588a2">power_manager_error_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__power__manager.html#ga3bfcc33858329e2b39a2c5c792db7cbe">POWER_SYS_Deinit</a> (void)</td></tr>
<tr class="memdesc:ga3bfcc33858329e2b39a2c5c792db7cbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function deinitializes the Power manager.  <a href="#ga3bfcc33858329e2b39a2c5c792db7cbe">More...</a><br/></td></tr>
<tr class="separator:ga3bfcc33858329e2b39a2c5c792db7cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31ef8f68c2a505c35bb440a2a8872c73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__power__manager.html#ga935122cf5948742441f087ac3f1588a2">power_manager_error_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__power__manager.html#ga31ef8f68c2a505c35bb440a2a8872c73">POWER_SYS_SetMode</a> (uint8_t powerModeIndex)</td></tr>
<tr class="memdesc:ga31ef8f68c2a505c35bb440a2a8872c73"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function configures the power mode.  <a href="#ga31ef8f68c2a505c35bb440a2a8872c73">More...</a><br/></td></tr>
<tr class="separator:ga31ef8f68c2a505c35bb440a2a8872c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e5663a16eebb2e6fb0ab68332254bcd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__power__manager.html#ga935122cf5948742441f087ac3f1588a2">power_manager_error_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__power__manager.html#ga4e5663a16eebb2e6fb0ab68332254bcd">POWER_SYS_GetMode</a> (uint8_t *powerModeIndexPtr)</td></tr>
<tr class="memdesc:ga4e5663a16eebb2e6fb0ab68332254bcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns power mode set as the last one.  <a href="#ga4e5663a16eebb2e6fb0ab68332254bcd">More...</a><br/></td></tr>
<tr class="separator:ga4e5663a16eebb2e6fb0ab68332254bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68f48994cdb57587be48260c4215d54d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__power__manager.html#ga935122cf5948742441f087ac3f1588a2">power_manager_error_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__power__manager.html#ga68f48994cdb57587be48260c4215d54d">POWER_SYS_GetModeConfig</a> (<a class="el" href="group__power__manager.html#structpower__manager__user__config__t">power_manager_user_config_t</a> **powerModePtr)</td></tr>
<tr class="memdesc:ga68f48994cdb57587be48260c4215d54d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns user configuration structure of power mode set as the last one.  <a href="#ga68f48994cdb57587be48260c4215d54d">More...</a><br/></td></tr>
<tr class="separator:ga68f48994cdb57587be48260c4215d54d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c7aa3a79473d4893afce3be94c90ce3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__power__manager.html#ga307c693b6f883df898b9210262755d40">power_manager_modes_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__power__manager.html#ga6c7aa3a79473d4893afce3be94c90ce3">POWER_SYS_GetRunningMode</a> (void)</td></tr>
<tr class="memdesc:ga6c7aa3a79473d4893afce3be94c90ce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns currently running power mode.  <a href="#ga6c7aa3a79473d4893afce3be94c90ce3">More...</a><br/></td></tr>
<tr class="separator:ga6c7aa3a79473d4893afce3be94c90ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10152697a5e14eae21473632aef99f49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__power__manager.html#gaf0c24dfbcfffe38404e9974f56369355">power_manager_callback_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__power__manager.html#ga10152697a5e14eae21473632aef99f49">POWER_SYS_GetErroneousDriver</a> (void)</td></tr>
<tr class="memdesc:ga10152697a5e14eae21473632aef99f49"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the last failed notification callback.  <a href="#ga10152697a5e14eae21473632aef99f49">More...</a><br/></td></tr>
<tr class="separator:ga10152697a5e14eae21473632aef99f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga847f0e3791457980be62bf3d00cd917e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__power__manager.html#ga935122cf5948742441f087ac3f1588a2">power_manager_error_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__power__manager.html#ga847f0e3791457980be62bf3d00cd917e">POWER_SYS_RegisterCallbackFunction</a> (<a class="el" href="group__power__manager.html#structpower__manager__dynamic__callback__user__config__t">power_manager_dynamic_callback_user_config_t</a> *callbackPtr, <a class="el" href="group__power__manager.html#gaf0c24dfbcfffe38404e9974f56369355">power_manager_callback_handle_t</a> *callbackHandlePtr)</td></tr>
<tr class="memdesc:ga847f0e3791457980be62bf3d00cd917e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function registers notification callback.  <a href="#ga847f0e3791457980be62bf3d00cd917e">More...</a><br/></td></tr>
<tr class="separator:ga847f0e3791457980be62bf3d00cd917e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaec5c0b95653c64451143a4d13ecc0a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__power__manager.html#ga935122cf5948742441f087ac3f1588a2">power_manager_error_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__power__manager.html#gaaec5c0b95653c64451143a4d13ecc0a6">POWER_SYS_UnregisterCallbackFunction</a> (<a class="el" href="group__power__manager.html#gaf0c24dfbcfffe38404e9974f56369355">power_manager_callback_handle_t</a> callbackHandle)</td></tr>
<tr class="memdesc:gaaec5c0b95653c64451143a4d13ecc0a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function unregisters specified notification callback.  <a href="#gaaec5c0b95653c64451143a4d13ecc0a6">More...</a><br/></td></tr>
<tr class="separator:gaaec5c0b95653c64451143a4d13ecc0a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada618e45824a2efae8ffd3e862b290fe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__power__manager.html#gada618e45824a2efae8ffd3e862b290fe">POWER_SYS_GetVeryLowPowerModeStatus</a> (void)</td></tr>
<tr class="memdesc:gada618e45824a2efae8ffd3e862b290fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns whether very low power mode is running.  <a href="#gada618e45824a2efae8ffd3e862b290fe">More...</a><br/></td></tr>
<tr class="separator:gada618e45824a2efae8ffd3e862b290fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bc7f720979d8a76ddd8e7f726e89161"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__power__manager.html#ga9bc7f720979d8a76ddd8e7f726e89161">POWER_SYS_GetLowLeakageWakeupResetStatus</a> (void)</td></tr>
<tr class="memdesc:ga9bc7f720979d8a76ddd8e7f726e89161"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns whether reset was caused by low leakage wake up.  <a href="#ga9bc7f720979d8a76ddd8e7f726e89161">More...</a><br/></td></tr>
<tr class="separator:ga9bc7f720979d8a76ddd8e7f726e89161"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>


<h3><a class="anchor" id="power"></a>Power Manager</h3><div class="textblock"><h1>Overview</h1>
Low Power Manager provides API to handle the device power modes. It also supports run-time switching between multiple power modes. Each power mode is described by configuration structures with multiple power-related options. Low Power Manager provides a notification mechanism for registered callbacks and API for static and dynamic callback registration.The Power Manager driver is developed on top of the SMC HAL, PMC HAL and RCM HAL.<h2>This is an example to initialize the Power Manager: </h2>
~~~~~{.c} </p>
<pre class="fragment">#include "fsl_power_manager.h"

/* Definition of power manager callback */
power_manager_error_code_t callback0(power_manager_callback_type_t type,
    power_manager_user_config_t * configPtr,
    power_manager_callback_data_t * dataPtr)
{

    power_manager_error_code_t ret = kPowerManagerError;

    ...
    ...
    ...

    return ret;
}

...
...
...
...
...
/* Main function */
int main(void)
{
    /* Callback configuration */
    user_callback_data_t callbackData0;

    power_manager_static_callback_user_config_t callbackCfg0 = { callback0,
            kPowerManagerCallbackBeforeAfter,
            (power_manager_callback_data_t*) &amp;callbackData0 };

    power_manager_static_callback_user_config_t * callbacks[] =
            { &amp;callbackCfg0 };


    /* Power modes configurations */
    power_manager_user_config_t vlprConfig;
    power_manager_user_config_t stopConfig;

    power_manager_user_config_t *powerConfigs[] = {&amp;vlprConfig, &amp;stopConfig};

    /* Definition of transition to and out these power modes */
    vlprConfig.mode = kPowerManagerVlpr;
    vlprConfig.policy = kPowerManagerPolicyAgreement;
    vlprConfig.sleepOnExitValue = false;
    vlprConfig.sleepOnExitOption = false;

    stopConfig = vlprConfig;
    stopConfig.mode = kPowerManagerStop;

    /* Calling of init method */
    POWER_SYS_Init(&amp;powerConfigs, 2U, &amp;callbacks, 1U);
}
</pre><p> ~~~~~{.c}<h2>This is an example to switch into a desired power mode: </h2>
~~~~~{.c} </p>
<pre class="fragment">#include "fsl_power_manager.h"

/* Index into array containing configuration of very low power run mode - vlpr */
#define MODE_VLPR 0U

/* Initialization */
power_manager_user_config_t vlprConfig;
...
...
...
power_manager_user_config_t *powerConfigs[1] = {&amp;vlprConfig};

/* Switch to required power mode */
power_manager_error_code_t ret = POWER_SYS_SetMode(MODE_VLPR);

if (ret != kPowerManagerSuccess) 
{
    printf("POWER_SYS_SetMode(powerMode5) returns : %u\n\r",ret);
}
</pre>~~~~~{.c} </div><hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structpower__manager__user__config__t" id="structpower__manager__user__config__t"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct power_manager_user_config_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>This structure defines Kinetis power mode with additional power options and specifies transition to and out of this mode. Application may define multiple power modes and switch between them. List of defined power modes is passed to the Power manager during initialization as an array of references to structures of this type (see <a class="el" href="group__power__manager.html#ga558a5f12d76ff23810fc637642f21d59" title="Power manager initialization for operation. ">POWER_SYS_Init()</a>). Power modes can be switched by calling <a class="el" href="group__power__manager.html#ga31ef8f68c2a505c35bb440a2a8872c73" title="This function configures the power mode. ">POWER_SYS_SetMode()</a> which accepts index to the list of power modes passed during manager initialization. Currently used power mode can be retrieved by calling <a class="el" href="group__power__manager.html#ga4e5663a16eebb2e6fb0ab68332254bcd" title="This function returns power mode set as the last one. ">POWER_SYS_GetMode()</a>, which returns index of the current power mode, or by <a class="el" href="group__power__manager.html#ga68f48994cdb57587be48260c4215d54d" title="This function returns user configuration structure of power mode set as the last one. ">POWER_SYS_GetModeConfig()</a>, which returns reference to the structure of current mode. List of power mode configuration structure members depends on power options available for specific chip. Complete list contains: mode - Kinetis power mode. List of available modes is chip-specific. See power_manager_modes_t list of modes. This item is common for all Kinetis chips. policy - Power mode change policy. Specifies whether the callbacks notified before the power mode change can prohibit the switch or callback notification results are ignored forcing the switch. This item is common for all Kinetis chips. sleepOnExitOption - Controls whether the sleep-on-exit option value is used (when set to true) or ignored (when set to false). See sleepOnExitValue. This item is common for all Kinetis chips. sleepOnExitValue - When set to true, ARM core returns to sleep (Kientis wait modes) or deep sleep state (Kinetis stop modes) after interrupt service finishes. When set to false, core stays woken-up. This item is common for all Kinetis chips. lowPowerWakeUpOnInterruptOption - Controls whether the wake-up-on-interrupt option value is used (when set to true) or ignored (when set to false). See lowPowerWakeUpOnInterruptOption. This item is chip-specific. sleepOnExitValue - When set to true, system exits to Run mode when any interrupt occurs while in Very low power run, Very low power wait or Very low power stop mode. This item is chip-specific. powerOnResetDetectionOption - Controls whether the power on reset detection option value is used (when set to true) or ignored (when set to false). See powerOnResetDetectionOption. This item is chip-specific. powerOnResetDetectionValue - When set to true, power on reset detection circuit is enabled in Very low leakage stop 0 mode. When set to false, circuit is disabled. This item is chip-specific. RAM2PartitionOption - Controls whether the RAM2 partition power option value is used (when set to true) or ignored (when set to false). See RAM2PartitionValue. This item is chip-specific. RAM2PartitionValue - When set to true, RAM2 partition content is retained through Very low leakage stop 2 mode. When set to false, RAM2 partition power is disabled and memory content lost. This item is chip-specific. lowPowerOscillatorOption - Controls whether the Low power oscillator power option value is used (when set to true) or ignored (when set to false). See lowPowerOscillatorValue. This item is chip-specific. lowPowerOscillatorValue - When set to true, the 1 kHz Low power oscillator is enabled in any Low leakage or Very low leakage stop mode. When set to false, oscillator is disabled in these modes. This item is chip-specific. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:a7ba586d29c06a214643e0c7580d0d9de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ba586d29c06a214643e0c7580d0d9de"></a>
<a class="el" href="group__power__manager.html#ga307c693b6f883df898b9210262755d40">power_manager_modes_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mode</b></td></tr>
<tr class="separator:a7ba586d29c06a214643e0c7580d0d9de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae254d62df5f05b1a38992f9078d44bd9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae254d62df5f05b1a38992f9078d44bd9"></a>
<a class="el" href="group__power__manager.html#ga557e8588368b90f97ba0a6fff173a447">power_manager_policy_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>policy</b></td></tr>
<tr class="separator:ae254d62df5f05b1a38992f9078d44bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff008e37e3303a75c048b8d0ff8e482"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ff008e37e3303a75c048b8d0ff8e482"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>sleepOnExitOption</b></td></tr>
<tr class="separator:a5ff008e37e3303a75c048b8d0ff8e482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60bb9905fefb991a8b5fed4dd93b5283"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a60bb9905fefb991a8b5fed4dd93b5283"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>sleepOnExitValue</b></td></tr>
<tr class="separator:a60bb9905fefb991a8b5fed4dd93b5283"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>

</div>
</div>
<a name="structpower__manager__static__callback__user__config__t" id="structpower__manager__static__callback__user__config__t"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct power_manager_static_callback_user_config_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>This structure holds configuration of callbacks passed to the Power manager during its initialization. Callbacks of this type are expected to be statically allocated. This structure contains following application-defined data: callback - pointer to the callback function callbackType - specifies when the callback is called callbackData - pointer to the data passed to the callback </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:a9b5186f12806cbdd847dadc77922fe24"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b5186f12806cbdd847dadc77922fe24"></a>
<a class="el" href="group__power__manager.html#ga4a17cc3e84a51eeed42fb0a5365b12e3">power_manager_callback_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>callback</b></td></tr>
<tr class="separator:a9b5186f12806cbdd847dadc77922fe24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae11221ad6aa306fc5f8c941fc947f2df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae11221ad6aa306fc5f8c941fc947f2df"></a>
<a class="el" href="group__power__manager.html#ga63bea534f09850d600e1bce7f76dcd1b">power_manager_callback_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>callbackType</b></td></tr>
<tr class="separator:ae11221ad6aa306fc5f8c941fc947f2df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e587285ddc1a0664d001ae18123d837"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e587285ddc1a0664d001ae18123d837"></a>
<a class="el" href="group__power__manager.html#gaf425e2ead1248e49133d9cb0b733f5e5">power_manager_callback_data_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>callbackData</b></td></tr>
<tr class="separator:a4e587285ddc1a0664d001ae18123d837"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>

</div>
</div>
<a name="structpower__manager__dynamic__callback__user__config__t" id="structpower__manager__dynamic__callback__user__config__t"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct power_manager_dynamic_callback_user_config_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>This structure holds configuration of callbacks registered to the Power manager during its run-time through <a class="el" href="group__power__manager.html#ga847f0e3791457980be62bf3d00cd917e" title="This function registers notification callback. ">POWER_SYS_RegisterCallbackFunction()</a>. Dynamically registered callbacks are managed as a double linked list where link order is handled by the Power manager. This structure contains both application-defined data and data handled by the Power manager: callback - pointer to the callback function, defined by the application callbackType - specifies when the callback is called, defined by the application callbackData - pointer to the data passed to the callback, defined by the application callbackPriority - specifies order in which are callbacks called, defined by the application handle - callback ID, defined by the Power manager prev - previous list node reference, defined by the Power manager next - next list node reference, defined by the Power manager </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:ac21246f25431ca2db09f7fc9ab7a5284"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac21246f25431ca2db09f7fc9ab7a5284"></a>
<a class="el" href="group__power__manager.html#ga4a17cc3e84a51eeed42fb0a5365b12e3">power_manager_callback_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>callback</b></td></tr>
<tr class="separator:ac21246f25431ca2db09f7fc9ab7a5284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a594c9c14bd01d264f118acb0119a1d6c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a594c9c14bd01d264f118acb0119a1d6c"></a>
<a class="el" href="group__power__manager.html#ga63bea534f09850d600e1bce7f76dcd1b">power_manager_callback_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>callbackType</b></td></tr>
<tr class="separator:a594c9c14bd01d264f118acb0119a1d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe311f58437f10551e562ed21a70d151"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe311f58437f10551e562ed21a70d151"></a>
<a class="el" href="group__power__manager.html#gaf425e2ead1248e49133d9cb0b733f5e5">power_manager_callback_data_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>callbackData</b></td></tr>
<tr class="separator:abe311f58437f10551e562ed21a70d151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff4300279de545f99a20c78420c294ac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff4300279de545f99a20c78420c294ac"></a>
<a class="el" href="group__power__manager.html#gaf3b9a189d84fd798b7e293e070389753">power_manager_callback_priority_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>callbackPriority</b></td></tr>
<tr class="separator:aff4300279de545f99a20c78420c294ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc57fffcc284260a4c441b0a54206fd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3dc57fffcc284260a4c441b0a54206fd"></a>
<a class="el" href="group__power__manager.html#gaf0c24dfbcfffe38404e9974f56369355">power_manager_callback_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>handle</b></td></tr>
<tr class="separator:a3dc57fffcc284260a4c441b0a54206fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedbedbb70e5e3d9aa9a28bca8d2dd080"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aedbedbb70e5e3d9aa9a28bca8d2dd080"></a>
struct <br class="typebreak"/>
_power_manager_dynamic_callback_user_config *&#160;</td><td class="memItemRight" valign="bottom"><b>prev</b></td></tr>
<tr class="separator:aedbedbb70e5e3d9aa9a28bca8d2dd080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a980e7f0062c555abd50c7aeab4d748cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a980e7f0062c555abd50c7aeab4d748cc"></a>
struct <br class="typebreak"/>
_power_manager_dynamic_callback_user_config *&#160;</td><td class="memItemRight" valign="bottom"><b>next</b></td></tr>
<tr class="separator:a980e7f0062c555abd50c7aeab4d748cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>

</div>
</div>
<a name="structpower__manager__state__t" id="structpower__manager__state__t"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct power_manager_state_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Power manager internal structure. Contains data necessary for Power manager proper function. Stores references to registered power mode configurations, statically and dynamically registered callbacks, information about their numbers and other internal data. This structure is statically allocated and initialized after <a class="el" href="group__power__manager.html#ga558a5f12d76ff23810fc637642f21d59" title="Power manager initialization for operation. ">POWER_SYS_Init()</a> call. It contains: configs - Reference to array of power mode configuration structures. Filled once during <a class="el" href="group__power__manager.html#ga558a5f12d76ff23810fc637642f21d59" title="Power manager initialization for operation. ">POWER_SYS_Init()</a> call. staticCallbacks - Reference to array of statically registered callbacks. Filled once during <a class="el" href="group__power__manager.html#ga558a5f12d76ff23810fc637642f21d59" title="Power manager initialization for operation. ">POWER_SYS_Init()</a> call. dynamicCallbacks - Reference to linked list of dynamically registered callbacks. Accessed during <a class="el" href="group__power__manager.html#ga847f0e3791457980be62bf3d00cd917e" title="This function registers notification callback. ">POWER_SYS_RegisterCallbackFunction()</a> and <a class="el" href="group__power__manager.html#gaaec5c0b95653c64451143a4d13ecc0a6" title="This function unregisters specified notification callback. ">POWER_SYS_UnregisterCallbackFunction()</a> calls. callbacksHandleCounter - Internal generator of callback handles. lastErroneousHandle - Stores handle of last callback which failed during notification call while running <a class="el" href="group__power__manager.html#ga31ef8f68c2a505c35bb440a2a8872c73" title="This function configures the power mode. ">POWER_SYS_SetMode()</a>. configsNumber - Number of power mode configuration passed during Power manager initialization. Size of array reference by configs. staticCallbacksNumber - Number of statically registered callbacks passed during Power manager initialization. Size of array reference by staticCallbacks. dynamicCallbacksNumber - Number of dynamically registered callbacks. Size of linked list referenced by dynamicCallbacks. currentConfig - POwer mode set as the last one. Index to the array referenced by configs. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:a90826f2c35188873d1b3a56377f7fa97"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a90826f2c35188873d1b3a56377f7fa97"></a>
<a class="el" href="group__power__manager.html#structpower__manager__user__config__t">power_manager_user_config_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><b>configs</b> )[]</td></tr>
<tr class="separator:a90826f2c35188873d1b3a56377f7fa97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ee0d214166db12d815835116b4761c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa8ee0d214166db12d815835116b4761c"></a>
<a class="el" href="group__power__manager.html#structpower__manager__static__callback__user__config__t">power_manager_static_callback_user_config_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><b>staticCallbacks</b> )[]</td></tr>
<tr class="separator:aa8ee0d214166db12d815835116b4761c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a024a147d0921be9ff773e510fb2c6159"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a024a147d0921be9ff773e510fb2c6159"></a>
<a class="el" href="group__power__manager.html#structpower__manager__dynamic__callback__user__config__t">power_manager_dynamic_callback_user_config_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>dynamicCallbacks</b></td></tr>
<tr class="separator:a024a147d0921be9ff773e510fb2c6159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac18a4b5257f418157cee2f8b51883c44"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac18a4b5257f418157cee2f8b51883c44"></a>
<a class="el" href="group__power__manager.html#gaf0c24dfbcfffe38404e9974f56369355">power_manager_callback_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>callbacksHandleCounter</b></td></tr>
<tr class="separator:ac18a4b5257f418157cee2f8b51883c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46885de25cfc7d3fb9d53c2c174d6314"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46885de25cfc7d3fb9d53c2c174d6314"></a>
<a class="el" href="group__power__manager.html#gaf0c24dfbcfffe38404e9974f56369355">power_manager_callback_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>lastErroneousHandle</b></td></tr>
<tr class="separator:a46885de25cfc7d3fb9d53c2c174d6314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f9e07b6ef9042758eaffc445835701"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93f9e07b6ef9042758eaffc445835701"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>configsNumber</b></td></tr>
<tr class="separator:a93f9e07b6ef9042758eaffc445835701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8192aa8b38df7747c7d5ff4f968fec5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8192aa8b38df7747c7d5ff4f968fec5"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>staticCallbacksNumber</b></td></tr>
<tr class="separator:af8192aa8b38df7747c7d5ff4f968fec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa24414f93dd1be2180fd70b8db62e864"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa24414f93dd1be2180fd70b8db62e864"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>dynamicCallbacksNumber</b></td></tr>
<tr class="separator:aa24414f93dd1be2180fd70b8db62e864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af65cb722d400920fb0270b6028266f68"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af65cb722d400920fb0270b6028266f68"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>currentConfig</b></td></tr>
<tr class="separator:af65cb722d400920fb0270b6028266f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga9ae951cf37a5ce9ba97d883434c298b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define POWER_SYS_CALLBACK_BEFORE&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used to identify callbacks invoked before the power mode change. See power_manager_callback_type_t. </p>

</div>
</div>
<a class="anchor" id="ga33c3bbae401fac6f7cbcf2f9bfd44849"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define POWER_SYS_CALLBACK_AFTER&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used to identify callbacks invoked after the power mode change. See power_manager_callback_type_t. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="gaf3b9a189d84fd798b7e293e070389753"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint8_t <a class="el" href="group__power__manager.html#gaf3b9a189d84fd798b7e293e070389753">power_manager_callback_priority_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used in the dynamically registered callback configuration structure (<a class="el" href="group__power__manager.html#structpower__manager__dynamic__callback__user__config__t" title="Dynamically allocated callback. ">power_manager_dynamic_callback_user_config_t</a>). Defines invocation order of the registered callbacks (callbacks registered by the <a class="el" href="group__power__manager.html#ga847f0e3791457980be62bf3d00cd917e" title="This function registers notification callback. ">POWER_SYS_RegisterCallbackFunction()</a>). Lower number has higher priority. In cases of multiple callbacks registered with the same priority, the registration order is decisive (first registered is first serviced). Supported priorities are in range of 0-255, however, priorities in range 0-7 are reserved for system purposes. Statically registered callbacks (<a class="el" href="group__power__manager.html#structpower__manager__static__callback__user__config__t" title="Statically allocated callback. ">power_manager_static_callback_user_config_t</a>) passed during Power manager initialization (see <a class="el" href="group__power__manager.html#ga558a5f12d76ff23810fc637642f21d59" title="Power manager initialization for operation. ">POWER_SYS_Init()</a>) have fixed priority and are always serviced after the dynamically registered callbacks (as if they had priority 256). </p>

</div>
</div>
<a class="anchor" id="gaf0c24dfbcfffe38404e9974f56369355"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="group__power__manager.html#gaf0c24dfbcfffe38404e9974f56369355">power_manager_callback_handle_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines unique identification of registered callback. Used for last failed callback identification (see <a class="el" href="group__power__manager.html#ga10152697a5e14eae21473632aef99f49" title="This function returns the last failed notification callback. ">POWER_SYS_GetErroneousDriver()</a>) and callback registration removal (see <a class="el" href="group__power__manager.html#gaaec5c0b95653c64451143a4d13ecc0a6" title="This function unregisters specified notification callback. ">POWER_SYS_UnregisterCallbackFunction()</a>). For statically registered callbacks (see <a class="el" href="group__power__manager.html#ga558a5f12d76ff23810fc637642f21d59" title="Power manager initialization for operation. ">POWER_SYS_Init()</a>) the handle is equal to callback position in the array of registered callbacks counted from 1 (e.g. if two callbacks are registered the callback with index 0 has handle 1 and callback with index 1 has handle 2). For dynamically registered callbacks the handle is returned by <a class="el" href="group__power__manager.html#ga847f0e3791457980be62bf3d00cd917e" title="This function registers notification callback. ">POWER_SYS_RegisterCallbackFunction()</a> and is part of <a class="el" href="group__power__manager.html#structpower__manager__dynamic__callback__user__config__t" title="Dynamically allocated callback. ">power_manager_dynamic_callback_user_config_t</a> structure. Handlers generation is reset after <a class="el" href="group__power__manager.html#ga558a5f12d76ff23810fc637642f21d59" title="Power manager initialization for operation. ">POWER_SYS_Init()</a> call. Valid handle has non-zero, 32-bit value. </p>

</div>
</div>
<a class="anchor" id="gaf425e2ead1248e49133d9cb0b733f5e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void <a class="el" href="group__power__manager.html#gaf425e2ead1248e49133d9cb0b733f5e5">power_manager_callback_data_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reference to data of this type is passed during callback registration. The reference is part of the <a class="el" href="group__power__manager.html#structpower__manager__static__callback__user__config__t" title="Statically allocated callback. ">power_manager_static_callback_user_config_t</a> or <a class="el" href="group__power__manager.html#structpower__manager__dynamic__callback__user__config__t" title="Dynamically allocated callback. ">power_manager_dynamic_callback_user_config_t</a> structure and is passed to the callback during power mode change notifications (see <a class="el" href="group__power__manager.html#ga31ef8f68c2a505c35bb440a2a8872c73" title="This function configures the power mode. ">POWER_SYS_SetMode()</a> and power_manager_callback_t). </p>

</div>
</div>
<a class="anchor" id="ga4a17cc3e84a51eeed42fb0a5365b12e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__power__manager.html#ga935122cf5948742441f087ac3f1588a2">power_manager_error_code_t</a>(*  power_manager_callback_t)(<a class="el" href="group__power__manager.html#ga63bea534f09850d600e1bce7f76dcd1b">power_manager_callback_type_t</a> type, <a class="el" href="group__power__manager.html#structpower__manager__user__config__t">power_manager_user_config_t</a> *configPtr, <a class="el" href="group__power__manager.html#gaf425e2ead1248e49133d9cb0b733f5e5">power_manager_callback_data_t</a> *dataPtr)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declaration of callback. It is common for statically and dynamically registered callbacks. Reference to function of this type is part of <a class="el" href="group__power__manager.html#structpower__manager__static__callback__user__config__t" title="Statically allocated callback. ">power_manager_static_callback_user_config_t</a> and <a class="el" href="group__power__manager.html#structpower__manager__dynamic__callback__user__config__t" title="Dynamically allocated callback. ">power_manager_dynamic_callback_user_config_t</a> callback configuration structure. Depending on callback type, function of this prototype is called during power mode change (see <a class="el" href="group__power__manager.html#ga31ef8f68c2a505c35bb440a2a8872c73" title="This function configures the power mode. ">POWER_SYS_SetMode()</a>) before the mode change, after it or in both cases to notify about the change progress (see power_manager_callback_type_t). When called, type of the notification is passed as parameter along with reference to entered power mode configuration structure (see <a class="el" href="group__power__manager.html#structpower__manager__user__config__t" title="Power mode user configuration structure. ">power_manager_user_config_t</a>) and any data passed during the callback registration (see power_manager_callback_data_t). When notified before the mode change, depending on the power mode change policy (see power_manager_policy_t) the callback may deny the mode change by returning any error code different from kPowerManagerSuccess (see <a class="el" href="group__power__manager.html#ga31ef8f68c2a505c35bb440a2a8872c73" title="This function configures the power mode. ">POWER_SYS_SetMode()</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Notification type. Denotes whether the callback is invoked before the power mode change (then the type has value kPowerManagerCallbackBefore) or after successful or unsuccessful mode change (value kPowerManagerCallbackAfter). </td></tr>
    <tr><td class="paramname">configPtr</td><td>Entered power mode. Refers to the power mode configuration structure which contains settings of now entered (when type is kPowerManagerCallbackBefore) or exited mode (when type is kPowerManagerCallbackAftrer). </td></tr>
    <tr><td class="paramname">dataPtr</td><td>Callback data. Refers to the data passed during callback registration. Intended to pass any driver or application data such as internal state information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code or kPowerManagerSuccess. </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga307c693b6f883df898b9210262755d40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__power__manager.html#ga307c693b6f883df898b9210262755d40">power_manager_modes_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines power mode. Used in the power mode configuration structure (<a class="el" href="group__power__manager.html#structpower__manager__user__config__t" title="Power mode user configuration structure. ">power_manager_user_config_t</a>). From ARM core perspective, Power modes can be generally divided to run modes (High speed run, Run and Very low power run), sleep (Wait and Very low power wait) and deep sleep modes (all Stop modes). List of power modes supported by specific chip along with requirements for entering and exiting of these modes can be found in chip documentation. List of all supported power modes: kPowerManagerHsrun - High speed run mode. Chip-specific. kPowerManagerRun - Run mode. All Kinetis chips. kPowerManagerVlpr - Very low power run mode. All Kinetis chips. kPowerManagerWait - Wait mode. All Kinetis chips. kPowerManagerVlpw - Very low power wait mode. All Kinetis chips. kPowerManagerStop - Stop mode. All Kinetis chips. kPowerManagerVlps - Very low power stop mode. All Kinetis chips. kPowerManagerPstop1 - Partial stop 1 mode. Chip-specific. kPowerManagerPstop2 - Partial stop 2 mode. Chip-specific. kPowerManagerLls - Low leakage stop mode. All Kinetis chips. kPowerManagerLls2 - Low leakage stop 2 mode. Chip-specific. kPowerManagerLls3 - Low leakage stop 3 mode. Chip-specific. kPowerManagerVlls0 - Very low leakage stop 0 mode. All Kinetis chips. kPowerManagerVlls1 - Very low leakage stop 1 mode. All Kinetis chips. kPowerManagerVlls2 - Very low leakage stop 2 mode. All Kinetis chips. kPowerManagerVlls3 - Very low leakage stop 3 mode. All Kinetis chips. </p>

</div>
</div>
<a class="anchor" id="ga935122cf5948742441f087ac3f1588a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__power__manager.html#ga935122cf5948742441f087ac3f1588a2">power_manager_error_code_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used as return value of Power manager functions. </p>

</div>
</div>
<a class="anchor" id="ga557e8588368b90f97ba0a6fff173a447"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__power__manager.html#ga557e8588368b90f97ba0a6fff173a447">power_manager_policy_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Define whether the power mode change is forced or not. Used in the power mode configuration structure (<a class="el" href="group__power__manager.html#structpower__manager__user__config__t" title="Power mode user configuration structure. ">power_manager_user_config_t</a>) to specify whether the mode switch initiated by the <a class="el" href="group__power__manager.html#ga31ef8f68c2a505c35bb440a2a8872c73" title="This function configures the power mode. ">POWER_SYS_SetMode()</a> depends on the callback notification results. For kPowerManagerPolicyForcible the power mode is changed regardless of the results, while kPowerManagerPolicyAgreement policy is used the <a class="el" href="group__power__manager.html#ga31ef8f68c2a505c35bb440a2a8872c73" title="This function configures the power mode. ">POWER_SYS_SetMode()</a> is exited when any of the callbacks returns error code. See also <a class="el" href="group__power__manager.html#ga31ef8f68c2a505c35bb440a2a8872c73" title="This function configures the power mode. ">POWER_SYS_SetMode()</a> description. </p>

</div>
</div>
<a class="anchor" id="ga63bea534f09850d600e1bce7f76dcd1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__power__manager.html#ga63bea534f09850d600e1bce7f76dcd1b">power_manager_callback_type_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used in the callback configuration structures (<a class="el" href="group__power__manager.html#structpower__manager__static__callback__user__config__t" title="Statically allocated callback. ">power_manager_static_callback_user_config_t</a> and <a class="el" href="group__power__manager.html#structpower__manager__dynamic__callback__user__config__t" title="Dynamically allocated callback. ">power_manager_dynamic_callback_user_config_t</a>) to specify when the registered callback will be called during power mode change initiated by <a class="el" href="group__power__manager.html#ga31ef8f68c2a505c35bb440a2a8872c73" title="This function configures the power mode. ">POWER_SYS_SetMode()</a>. Also used when callback is invoked to specify notification type. Callback can be invoked in following situations:</p>
<ul>
<li>before the power mode change (Callback return value can affect <a class="el" href="group__power__manager.html#ga31ef8f68c2a505c35bb440a2a8872c73" title="This function configures the power mode. ">POWER_SYS_SetMode()</a> execution. Refer to the <a class="el" href="group__power__manager.html#ga31ef8f68c2a505c35bb440a2a8872c73" title="This function configures the power mode. ">POWER_SYS_SetMode()</a> and power_manager_policy_t documentation).</li>
<li>after entering one of the run modes or after exiting from one of the (deep) sleep power modes back to the run mode.</li>
<li>after unsuccessful attempt to switch power mode Values used during callback registration:</li>
<li>kPowerManagerCallbackBefore</li>
<li>kPowerManagerCallbackAfter</li>
<li>kPowerManagerCallbackBeforeAfter Values used during callback invocation:</li>
<li>kPowerManagerCallbackBefore</li>
<li>kPowerManagerCallbackAfter</li>
<li>kPowerManagerCallbackFailed </li>
</ul>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga558a5f12d76ff23810fc637642f21d59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__power__manager.html#ga935122cf5948742441f087ac3f1588a2">power_manager_error_code_t</a> POWER_SYS_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__power__manager.html#structpower__manager__user__config__t">power_manager_user_config_t</a> *(*)&#160;</td>
          <td class="paramname"><em>powerConfigsPtr</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>configsNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__power__manager.html#structpower__manager__static__callback__user__config__t">power_manager_static_callback_user_config_t</a> *(*)&#160;</td>
          <td class="paramname"><em>callbacksPtr</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>callbacksNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function initializes the Power manager and its run-time state structure. Reference to an array of Power mode configuration structures has to be passed as a parameter along with a parameter specifying its size. At least one power mode configuration is required. Optionally, reference to the array of predefined callbacks can be passed with its size parameter. This can be used to pass callbacks directly without need of dynamic, run-time registration (see <a class="el" href="group__power__manager.html#ga847f0e3791457980be62bf3d00cd917e" title="This function registers notification callback. ">POWER_SYS_RegisterCallbackFunction()</a> and <a class="el" href="group__power__manager.html#gaaec5c0b95653c64451143a4d13ecc0a6" title="This function unregisters specified notification callback. ">POWER_SYS_UnregisterCallbackFunction()</a>). For details about static callbacks, refer to the <a class="el" href="group__power__manager.html#structpower__manager__static__callback__user__config__t" title="Statically allocated callback. ">power_manager_static_callback_user_config_t</a>. As Power manager stores only references to array of these structures, they have to exist while Power manager is used. It is expected that prior to the <a class="el" href="group__power__manager.html#ga558a5f12d76ff23810fc637642f21d59" title="Power manager initialization for operation. ">POWER_SYS_Init()</a> call the write-once protection register was configured appropriately allowing for entry to all required low power modes. The following is an example of how to set up two power modes and three callbacks, and initialize the Power manager with structures containing their settings. The example shows two possible ways the configuration structures can be stored (ROM or RAM), although it is expected that they will be placed in the read-only memory to save the RAM space. (Note: In the example it is assumed that the programmed chip doesn't support any optional power options described in the <a class="el" href="group__power__manager.html#structpower__manager__user__config__t" title="Power mode user configuration structure. ">power_manager_user_config_t</a>) : </p>
<div class="fragment"><div class="line">   <span class="keyword">const</span> <a class="code" href="group__power__manager.html#structpower__manager__user__config__t">power_manager_user_config_t</a> waitConfig = {</div>
<div class="line">       kPowerManagerVlpw,</div>
<div class="line">       kPowerManagerPolicyForcible,</div>
<div class="line">       <span class="keyword">true</span>,</div>
<div class="line">       <span class="keyword">true</span>,</div>
<div class="line">   };</div>
<div class="line"></div>
<div class="line">   <span class="keyword">const</span> <a class="code" href="group__power__manager.html#structpower__manager__static__callback__user__config__t">power_manager_static_callback_user_config_t</a> callbackCfg0 = {</div>
<div class="line">       callback0,</div>
<div class="line">       kPowerManagerCallbackBefore,</div>
<div class="line">       &amp;callback_data0</div>
<div class="line">   };</div>
<div class="line"></div>
<div class="line">   <span class="keyword">const</span> <a class="code" href="group__power__manager.html#structpower__manager__static__callback__user__config__t">power_manager_static_callback_user_config_t</a> callbackCfg1 = {</div>
<div class="line">       callback1,</div>
<div class="line">       kPowerManagerCallbackAfter,</div>
<div class="line">       &amp;callback_data1</div>
<div class="line">   };</div>
<div class="line"></div>
<div class="line">   <span class="keyword">const</span> <a class="code" href="group__power__manager.html#structpower__manager__static__callback__user__config__t">power_manager_static_callback_user_config_t</a> callbackCfg2 = {</div>
<div class="line">       callback2,</div>
<div class="line">       kPowerManagerCallbackBeforeAfter,</div>
<div class="line">       &amp;callback_data2</div>
<div class="line">   };</div>
<div class="line"></div>
<div class="line">   <span class="keyword">const</span> <a class="code" href="group__power__manager.html#structpower__manager__static__callback__user__config__t">power_manager_static_callback_user_config_t</a> * <span class="keyword">const</span> callbacks[] = {&amp;callbackCfg0, &amp;callbackCfg1, &amp;callbackCfg2};</div>
<div class="line"></div>
<div class="line">   <span class="keywordtype">void</span> main(<span class="keywordtype">void</span>)</div>
<div class="line">   {</div>
<div class="line">       <a class="code" href="group__power__manager.html#structpower__manager__user__config__t">power_manager_user_config_t</a> idleConfig;</div>
<div class="line">       <a class="code" href="group__power__manager.html#structpower__manager__user__config__t">power_manager_user_config_t</a> *powerConfigs[POWER_SYS_CONFIGURATIONS] = {&amp;idleConfig, &amp;idleConfig};</div>
<div class="line"></div>
<div class="line">       idleConfig.mode = kPowerManagerVlps;</div>
<div class="line">       idleConfig.policy = kPowerManagerPolicyForcible;</div>
<div class="line">       idleConfig.sleepOnExitOption = <span class="keyword">true</span>;</div>
<div class="line">       idleConfig.sleepOnExitValue = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">       <a class="code" href="group__power__manager.html#ga558a5f12d76ff23810fc637642f21d59">POWER_SYS_Init</a>(&amp;powerConfigs, 2U, &amp;callbacks, 3U);</div>
<div class="line"></div>
<div class="line">       <a class="code" href="group__power__manager.html#ga31ef8f68c2a505c35bb440a2a8872c73">POWER_SYS_SetMode</a>(0U);</div>
<div class="line"></div>
<div class="line">   }</div>
<div class="line">* </div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">powerConfigsPtr</td><td>A pointer to an array with references to all power configurations which will be handled by Power manager. </td></tr>
    <tr><td class="paramname">configsNumber</td><td>Number of power configurations. Size of powerConfigsPtr array. </td></tr>
    <tr><td class="paramname">callbacksPtr</td><td>A pointer to an array with references to callback configurations. These callbacks are statically registered in the Power manager. If there are no callbacks to register during Power manager initialization, use NULL value. </td></tr>
    <tr><td class="paramname">callbacksNumber</td><td>Number of statically registered callbacks. Size of callbacksPtr array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code or kPowerManagerSuccess. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3bfcc33858329e2b39a2c5c792db7cbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__power__manager.html#ga935122cf5948742441f087ac3f1588a2">power_manager_error_code_t</a> POWER_SYS_Deinit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>An error code or kPowerManagerSuccess. </dd></dl>

</div>
</div>
<a class="anchor" id="ga31ef8f68c2a505c35bb440a2a8872c73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__power__manager.html#ga935122cf5948742441f087ac3f1588a2">power_manager_error_code_t</a> POWER_SYS_SetMode </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>powerModeIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function switches to one of the defined power modes. Requested mode number is passed as an input parameter. This function notifies all registered callback functions before the mode change (using kPowerManagerCallbackBefore set as callback type parameter), sets specific power options defined in the power mode configuration and enters the specified mode. In case of run modes (for example, Run, Very low power run, or High speed run), this function also invokes all registered callbacks after the mode change (using kPowerManagerCallbackAfter). In case of sleep or deep sleep modes, if the requested mode is not exited through a reset, these notifications are sent after the core wakes up. Callbacks are invoked in the following order: first, all dynamically registered callbacks are invoked ordered by the priority set during their registrations (see POWER_SYS_RegisterCallbackFunction). Then all statically registered callbacks are notified ordered by index in the static callbacks array (see callbacksPtr parameter of <a class="el" href="group__power__manager.html#ga558a5f12d76ff23810fc637642f21d59" title="Power manager initialization for operation. ">POWER_SYS_Init()</a>). The same order is used for before and after switch notifications. The notifications before the power mode switch can be used to obtain confirmation about the change from registered callbacks. If any registered callback denies the power mode change, further execution of this function depends on mode change policy defined in the user power mode configuration (see policy in the <a class="el" href="group__power__manager.html#structpower__manager__user__config__t" title="Power mode user configuration structure. ">power_manager_user_config_t</a>): the mode change is either forced (kPowerManagerPolicyForcible) or exited (kPowerManagerPolicyAgreement). When mode change is forced, the result of the before switch notifications are ignored. If agreement is required, if any callback returns an error code then further notifications before switch notifications are cancelled and all already notified callbacks are re-invoked with kPowerManagerCallbackAfter set as callback type parameter. The handler of the callback which returned error code during pre-switch notifications is stored (any error codes during callbacks re-invocation are ignored) and <a class="el" href="group__power__manager.html#ga10152697a5e14eae21473632aef99f49" title="This function returns the last failed notification callback. ">POWER_SYS_GetErroneousDriver()</a> can be used to get it. Regardless of the policies, if any callback returned an error code, an error code denoting in which phase the error occurred is returned when <a class="el" href="group__power__manager.html#ga31ef8f68c2a505c35bb440a2a8872c73" title="This function configures the power mode. ">POWER_SYS_SetMode()</a> exits. It is possible to enter any mode supported by the processor. Refer to the chip reference manual for list of available power modes. If it is necessary to switch into intermediate power mode prior to entering requested mode (for example, when switching from Run into Very low power wait through Very low power run mode), then the intermediate mode is entered without invoking the callback mechanism.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">powerkModeIndex</td><td>Requested power mode represented as an index into array of user-defined power mode configurations passed to the <a class="el" href="group__power__manager.html#ga558a5f12d76ff23810fc637642f21d59" title="Power manager initialization for operation. ">POWER_SYS_Init()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code or kPowerManagerSuccess. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4e5663a16eebb2e6fb0ab68332254bcd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__power__manager.html#ga935122cf5948742441f087ac3f1588a2">power_manager_error_code_t</a> POWER_SYS_GetMode </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>powerModeIndexPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns index of power mode which was set using <a class="el" href="group__power__manager.html#ga31ef8f68c2a505c35bb440a2a8872c73" title="This function configures the power mode. ">POWER_SYS_SetMode()</a> as the last one. If the power mode was entered even though some of the registered callback denied the mode change, or if any of the callbacks invoked after the entering/restoring run mode failed, then the return code of this function has kPowerManagerError value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">powerkModeIndex</td><td>Power mode which has been set represented as an index into array of power mode configurations passed to the <a class="el" href="group__power__manager.html#ga558a5f12d76ff23810fc637642f21d59" title="Power manager initialization for operation. ">POWER_SYS_Init()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code or kPowerManagerSuccess. </dd></dl>

</div>
</div>
<a class="anchor" id="ga68f48994cdb57587be48260c4215d54d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__power__manager.html#ga935122cf5948742441f087ac3f1588a2">power_manager_error_code_t</a> POWER_SYS_GetModeConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__power__manager.html#structpower__manager__user__config__t">power_manager_user_config_t</a> **&#160;</td>
          <td class="paramname"><em>powerModePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns reference to configuration structure which was set using <a class="el" href="group__power__manager.html#ga31ef8f68c2a505c35bb440a2a8872c73" title="This function configures the power mode. ">POWER_SYS_SetMode()</a> as the last one. If the current power mode was entered even though some of the registered callback denied the mode change, or if any of the callbacks invoked after the entering/restoring run mode failed, then the return code of this function has kPowerManagerError value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">powerModeIndexPtr</td><td>Pointer to power mode configuration structure of power mode set as last one. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code or kPowerManagerSuccess. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6c7aa3a79473d4893afce3be94c90ce3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__power__manager.html#ga307c693b6f883df898b9210262755d40">power_manager_modes_t</a> POWER_SYS_GetRunningMode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function reads hardware settings and returns currently running power mode. Generally, this function can return only kPowerManagerRun, kPowerManagerVlpr or kPowerManagerHsrun value.</p>
<dl class="section return"><dt>Returns</dt><dd>Currently used run power mode. </dd></dl>

</div>
</div>
<a class="anchor" id="ga10152697a5e14eae21473632aef99f49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__power__manager.html#gaf0c24dfbcfffe38404e9974f56369355">power_manager_callback_handle_t</a> POWER_SYS_GetErroneousDriver </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns handle of the last callback that failed during the power mode switch while the last <a class="el" href="group__power__manager.html#ga31ef8f68c2a505c35bb440a2a8872c73" title="This function configures the power mode. ">POWER_SYS_SetMode()</a> was called. If the last <a class="el" href="group__power__manager.html#ga31ef8f68c2a505c35bb440a2a8872c73" title="This function configures the power mode. ">POWER_SYS_SetMode()</a> call ended successfully, zero value is returned. Returned callback ID represents either the handle assigned to the callback during its dynamic registration (the handle return parameter of the <a class="el" href="group__power__manager.html#ga847f0e3791457980be62bf3d00cd917e" title="This function registers notification callback. ">POWER_SYS_RegisterCallbackFunction()</a>) or, in cases of statically registered callbacks, index in the array of static callbacks counted from 1 (for example, static callback at index 0 of the array has handle value 1, index 1 is represented by handle value 2 etc.)</p>
<dl class="section return"><dt>Returns</dt><dd>Zero or callback function handle. </dd></dl>

</div>
</div>
<a class="anchor" id="ga847f0e3791457980be62bf3d00cd917e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__power__manager.html#ga935122cf5948742441f087ac3f1588a2">power_manager_error_code_t</a> POWER_SYS_RegisterCallbackFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__power__manager.html#structpower__manager__dynamic__callback__user__config__t">power_manager_dynamic_callback_user_config_t</a> *&#160;</td>
          <td class="paramname"><em>callbackPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__power__manager.html#gaf0c24dfbcfffe38404e9974f56369355">power_manager_callback_handle_t</a> *&#160;</td>
          <td class="paramname"><em>callbackHandlePtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to dynamically register driver or application callback function into the Power manager. Callbacks are used during power mode switch to notify and receive acknowledge from registered functions: all functions which were registered with kPowerManagerCallbackBefore or kPowerManagerCallbackBeforeAfter callback type (see <a class="el" href="group__power__manager.html#structpower__manager__dynamic__callback__user__config__t" title="Dynamically allocated callback. ">power_manager_dynamic_callback_user_config_t</a> and power_manager_callback_type_t) are called before the power mode is switched. It is expected that these callbacks will acknowledge readiness for the power mode change. If any callback signals that it is not ready for the change, then subsequent mode change execution depends on the policy of the requested power mode configuration structure (see power_manager_policy_t). When the power mode is switched (in cases of run modes) or exited without a reset (in cases of sleep modes) then callbacks registered with kPowerManagerCallbackAfter or kPowerManagerCallbackBeforeAfter are invoked. Registered callback is invoked during each <a class="el" href="group__power__manager.html#ga31ef8f68c2a505c35bb440a2a8872c73" title="This function configures the power mode. ">POWER_SYS_SetMode()</a> call. An order of invocation of callbacks is specified by priority number (see power_manager_callback_priority_t). Callbacks with lower priority number are called first. In cases of multiple callbacks having the same priority, the first registered callback is serviced as first (FIFO). When called, reference to power_manager_callback_data_t registered with the callback are passed to the callback by the power manager, along with reference to power mode configuration reference to provide callback with all necessary information about power mode which being entered. Following successful registration, a handle identifying the callback is returned. This handle is used to identify last unsuccessfully invoked callback (see <a class="el" href="group__power__manager.html#ga10152697a5e14eae21473632aef99f49" title="This function returns the last failed notification callback. ">POWER_SYS_GetErroneousDriver()</a>) and for callback unregistration (see POWER_SYS_UnregisterCallbackFunction). See power_manager_callback_t for required callback prototype. Following is an example of usage: </p>
<div class="fragment"><div class="line">   <span class="keyword">struct </span>{</div>
<div class="line"></div>
<div class="line">     <span class="comment">//...</span></div>
<div class="line"></div>
<div class="line">   } callbackData;</div>
<div class="line"></div>
<div class="line">   <a class="code" href="group__power__manager.html#ga935122cf5948742441f087ac3f1588a2">power_manager_error_code_t</a> callback(<a class="code" href="group__power__manager.html#ga63bea534f09850d600e1bce7f76dcd1b">power_manager_callback_type_t</a> type,</div>
<div class="line">                                       <a class="code" href="group__power__manager.html#structpower__manager__user__config__t">power_manager_user_config_t</a> *config,</div>
<div class="line">                                       <a class="code" href="group__power__manager.html#gaf425e2ead1248e49133d9cb0b733f5e5">power_manager_callback_data_t</a> *dataPtr)</div>
<div class="line">   {</div>
<div class="line">       <span class="keywordflow">switch</span> (type) {</div>
<div class="line">       <span class="keywordflow">case</span> kPowerManagerCallbackBefore:</div>
<div class="line">           <span class="keywordflow">if</span> (config-&gt;mode &lt;= kPowerManagerVlpr)</div>
<div class="line">           {</div>
<div class="line">               <span class="comment">// Run modes</span></div>
<div class="line">               <span class="comment">//...</span></div>
<div class="line">           }</div>
<div class="line">           <span class="keywordflow">else</span></div>
<div class="line">           {</div>
<div class="line">               <span class="comment">// Sleep/deep sleep modes</span></div>
<div class="line">               <span class="comment">//...</span></div>
<div class="line">           }</div>
<div class="line">           <span class="keywordflow">break</span>;</div>
<div class="line">       <span class="keywordflow">case</span> kPowerManagerCallbackAfter:</div>
<div class="line">           <span class="keywordflow">if</span> (<a class="code" href="group__power__manager.html#ga6c7aa3a79473d4893afce3be94c90ce3">POWER_SYS_GetRunningMode</a>() == kPowerManagerRun)</div>
<div class="line">           {</div>
<div class="line">               <span class="comment">//...</span></div>
<div class="line">           }</div>
<div class="line">           <span class="keywordflow">else</span></div>
<div class="line">           {</div>
<div class="line">               <span class="comment">//...</span></div>
<div class="line">           }</div>
<div class="line">           <span class="keywordflow">break</span>;</div>
<div class="line">       }</div>
<div class="line">       <span class="keywordflow">return</span> kPowerManagerSuccess;</div>
<div class="line">   }</div>
<div class="line"></div>
<div class="line">   <span class="keywordtype">void</span> main (<span class="keywordtype">void</span>) {</div>
<div class="line">       <a class="code" href="group__power__manager.html#ga935122cf5948742441f087ac3f1588a2">power_manager_error_code_t</a> registrationStatus;</div>
<div class="line">       <a class="code" href="group__power__manager.html#gaf0c24dfbcfffe38404e9974f56369355">power_manager_callback_handle_t</a> callbackHandle;</div>
<div class="line">       <a class="code" href="group__power__manager.html#structpower__manager__dynamic__callback__user__config__t">power_manager_dynamic_callback_user_config_t</a> callbackDescriptor = {</div>
<div class="line">         &amp;callback,</div>
<div class="line">         kPowerManagerCallbackBeforeAfter,</div>
<div class="line">         &amp;callbackData,</div>
<div class="line">         255,</div>
<div class="line">         0,</div>
<div class="line">         NULL,</div>
<div class="line">         NULL</div>
<div class="line">       };</div>
<div class="line"></div>
<div class="line">       <span class="comment">//Power manager initialization</span></div>
<div class="line">       <span class="comment">//...</span></div>
<div class="line"></div>
<div class="line">       registrationStatus = <a class="code" href="group__power__manager.html#ga847f0e3791457980be62bf3d00cd917e">POWER_SYS_RegisterCallbackFunction</a>(&amp;callbackDescriptor, &amp;callbackHandle);</div>
<div class="line">   }</div>
<div class="line">* </div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callbackPtr</td><td>Structure with callback configuration. Used to specify callback address (power_manager_callback_t callback), type (power_manager_callback_type_t callbackType), data (power_manager_callback_data_t callbackData) and priority (power_manager_callback_priority_t callbackPriority). The rest of the structure content is used by the Power manager: the unique handle assigned to the callback and linked list references. Creation of this structure, including memory allocation, is managed by the application; only reference is stored in the Power manager therefore it has to be available during Power manager usage. If callback and its configuration structure has to be destroyed/deallocated it has to be unregistered from Power manager first. </td></tr>
    <tr><td class="paramname">callbackHandlePtr</td><td>Output parameter to return unique handle of registered callback. Only non-zero values are valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code or kPowerManagerSuccess. </dd></dl>

</div>
</div>
<a class="anchor" id="gaaec5c0b95653c64451143a4d13ecc0a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__power__manager.html#ga935122cf5948742441f087ac3f1588a2">power_manager_error_code_t</a> POWER_SYS_UnregisterCallbackFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__power__manager.html#gaf0c24dfbcfffe38404e9974f56369355">power_manager_callback_handle_t</a>&#160;</td>
          <td class="paramname"><em>callbackHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to unregister callback from the Power manager. After that, callback is no longer invoked. Callback to be removed is identified by handle received during its registration. If no registered callback matches the handle, kPowerManagerOutOfRangeError is returned. Only dynamically registered callbacks can be unregistered. This function can't be used to stop invocation of statically registered callbacks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callbackHandle</td><td>Handle identifying callback to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code or kPowerManagerSuccess. </dd></dl>

</div>
</div>
<a class="anchor" id="gada618e45824a2efae8ffd3e862b290fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool POWER_SYS_GetVeryLowPowerModeStatus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to detect whether very low power mode is running.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if processor runs in very low power mode, otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9bc7f720979d8a76ddd8e7f726e89161"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool POWER_SYS_GetLowLeakageWakeupResetStatus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to check that processor exited low leakage power mode through reset.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if processor was reset by low leakage wake up, otherwise false. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.5-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul class="foot">
    <li class="footer">Fri Jul 25 2014 &copy; 2014 Freescale Semiconductor, Inc. All rights reserved. 
    </li>
  </ul>
</div>
</body>
</html>
